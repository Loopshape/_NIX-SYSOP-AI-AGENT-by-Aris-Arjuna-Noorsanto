#!/bin/bash

# ███████╗██╗   ██╗███████╗ ██████╗ ██████╗ █████╗ ██╗
# ██╔════╝╚██╗ ██╔╝██╔════╝██╔═══██╗██╔══██╗██╔══██╗██║
# ███████╗ ╚████╔╝ █████╗  ██║   ██║██████╔╝███████║██║
# ╚════██║  ╚██╔╝  ██╔══╝  ██║   ██║██╔═══╝ ██╔══██║██║
# ███████║   ██║   ███████╗╚██████╔╝██║     ██║  ██║███████╗
# ╚══════╝   ╚═╝   ╚══════╝ ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚══════╝
#
# A self-contained AI orchestration framework for local LLMs.
# Version: 2.0.2 (Fix: Node.js dependency installation and path)

# --- Environment & Configuration ---
export AI_HOME="${AI_HOME:-$HOME/.sysop-ai}"
export TASKS_DIR="$AI_HOME/tasks"
export PROJECTS_DIR="$AI_HOME/projects"
export DB_DIR="$AI_HOME/db"
export SSH_DIR="$AI_HOME/ssh"
export AI_DATA_DB="$DB_DIR/ai_data.db"
export BLOBS_DB="$DB_DIR/blobs.db"
export WALLET_DB="$DB_DIR/wallet.db"
export SESSION_FILE="$AI_HOME/.session"
export OLLAMA_BIN="ollama"

# --- Utility Functions ---

# Check for required dependencies
check_dependencies() {
    local missing_deps=()
    # Added 'npm' as a required dependency for installing sqlite3
    local deps=("sqlite3" "node" "npm" "python3" "git" "$OLLAMA_BIN")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done
    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo "Error: Missing required dependencies: ${missing_deps[*]}. Please install them and try again."
        exit 1
    fi
}

# Install Node dependencies (sqlite3) locally within AI_HOME
install_node_deps() {
    local node_deps=("sqlite3")
    echo "[\x1b[34mINFO\x1b[0m] Checking and installing Node.js dependencies..."
    
    # Use npm to install if not present, installing into the AI_HOME prefix
    npm install "${node_deps[@]}" --prefix "$AI_HOME" &> /dev/null
    
    if [ -d "$AI_HOME/node_modules/sqlite3" ]; then
        echo "[\x1b[32mSUCCESS\x1b[0m] Node.js dependencies installed/verified in $AI_HOME/node_modules."
    else
        echo "[\x1b[31mERROR\x1b[0m] Failed to install Node.js dependencies. Please ensure npm is accessible and try running 'npm install sqlite3 --prefix $AI_HOME' manually."
        exit 1
    fi
}


# Setup the entire AI environment, including embedded scripts
setup_environment() {
    mkdir -p "$AI_HOME" "$TASKS_DIR" "$PROJECTS_DIR" "$DB_DIR" "$SSH_DIR"
    
    # Check and install Node dependencies first
    install_node_deps

    # Write the JavaScript Orchestrator
    cat > "$AI_HOME/orchestrator.js" << 'EOF'
const { exec } = require('child_process');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
// Since NODE_PATH is set in the calling shell script, 'sqlite3' should be found.
const sqlite3 = require('sqlite3').verbose();

const AI_HOME = process.env.AI_HOME;
const PROJECTS_DIR = process.env.PROJECTS_DIR;
const AI_DATA_DB_PATH = process.env.AI_DATA_DB;
const BLOBS_DB_PATH = process.env.BLOBS_DB;
const OLLAMA_BIN = process.env.OLLAMA_BIN || 'ollama';

const MODEL_POOL = ["phi3", "llama3", "codegemma"];

const aiDataDb = new sqlite3.Database(AI_DATA_DB_PATH);
const blobsDb = new sqlite3.Database(BLOBS_DB_PATH);

class ProofTracker {
    constructor(initialPrompt) {
        this.cycleIndex = initialPrompt.length;
        this.netWorthIndex = (this.cycleIndex % 128) << 2;
        this.entropyRatio = (this.cycleIndex ^ Date.now()) / 1000;
    }
    crosslineEntropy(data) {
        const hash = crypto.createHash('sha256').update(data).digest('hex');
        this.entropyRatio += parseInt(hash.substring(0, 8), 16);
    }
    proofCycle(converged) {
        this.cycleIndex += converged ? 1 : 0;
        this.netWorthIndex -= converged ? 0 : 1;
    }
    getState() { return { cycleIndex: this.cycleIndex, netWorthIndex: this.netWorthIndex, entropyRatio: this.entropyRatio }; }
}

class AIOrchestrator {
    constructor(prompt, options) {
        this.initialPrompt = prompt;
        this.options = options;
        this.taskId = crypto.createHash('sha256').update(Date.now().toString()).digest('hex');
        this.proofTracker = new ProofTracker(prompt);
    }

    runOllama(model, currentPrompt) {
        return new Promise((resolve, reject) => {
            console.log(`\n\x1b[34m[INFO]\x1b[0m Model \x1b[33m'${model}'\x1b[0m is thinking...`);
            const child = exec(`${OLLAMA_BIN} run ${model} "${currentPrompt.replace(/"/g, '\\"')}"`);
            let output = '';
            child.stdout.on('data', (data) => {
                process.stdout.write(`\x1b[2m${data}\x1b[0m`);
                output += data;
            });
            child.stderr.on('data', (data) => process.stderr.write(data));
            child.on('close', (code) => {
                if (code !== 0) return reject(`Model ${model} exited with code ${code}`);
                resolve(output.trim());
            });
        });
    }

    async recursiveConsensus() {
        let systemPrompt = `SYSTEM PROMPT: You are a world-class software engineer. Your response MUST be ONLY the requested artifact. Use markdown for all code blocks (e.g., \`\`\`python ... \`\`\`). Do not include any conversational text outside of the code blocks or explanations. User Task:\n`;
        let currentPrompt = systemPrompt + this.initialPrompt;
        let lastFusedOutput = "";
        let converged = false;

        for (let i = 0; i < 3 && !converged; i++) {
            const promises = MODEL_POOL.map(model => this.runOllama(model, currentPrompt).catch(e => e));
            const results = await Promise.all(promises);
            const validResults = results.filter(r => typeof r === 'string' && r.length > 0);
            
            if (validResults.length === 0) return "Error: All models failed to respond.";
            
            const fusedOutput = validResults.join('\n---\n').trim();
            this.proofTracker.crosslineEntropy(fusedOutput);

            // Simple convergence check: check if the first 100 characters match
            if (lastFusedOutput.substring(0, 100) === fusedOutput.substring(0, 100) && lastFusedOutput.length > 0) {
                converged = true;
                this.proofTracker.proofCycle(true);
            } else {
                this.proofTracker.proofCycle(false);
            }
            lastFusedOutput = fusedOutput;
            
            // Only feed back the core output, not the entire history
            currentPrompt = systemPrompt + this.initialPrompt + `\n[PREVIOUS ITERATION OUTPUT]\n${fusedOutput}`;
            this.logEvent('CONSENSUS_LOOP', `Iteration ${i + 1}, Converged: ${converged}`);
        }
        return lastFusedOutput;
    }

    parseCodeBlocks(content) {
        return [...content.matchAll(/```(\w+)\s*([\s\S]*?)```/g)].map(match => ({
            language: match[1].toLowerCase(),
            code: match[2].trim(),
        }));
    }

    async handleCodeGeneration(content) {
        const blocks = this.parseCodeBlocks(content);
        if (blocks.length === 0) return;
        
        const projectName = this.options.project || `task_${this.taskId.substring(0, 8)}`;
        const projectPath = path.join(PROJECTS_DIR, projectName);
        fs.mkdirSync(projectPath, { recursive: true });

        for (const [i, block] of blocks.entries()) {
            const ext = this.getFileExtension(block.language);
            // Simple file naming scheme: lang_index.ext
            const fileName = `${block.language}_${i}.${ext}`; 
            const filePath = path.join(projectPath, fileName);
            fs.writeFileSync(filePath, block.code);
            this.saveBlob(projectName, filePath, block.code);
            console.log(`\x1b[32m[SUCCESS]\x1b[0m Generated file: ${filePath}`);
        }
        this.gitCommit(projectName);
    }
    
    getFileExtension(lang) { return ({ python: 'py', javascript: 'js', html: 'html', css: 'css', php: 'php', sql: 'sql', bash: 'sh', go: 'go' })[lang] || 'txt'; }
    
    saveMemory(prompt, response) {
        const proofState = JSON.stringify(this.proofTracker.getState());
        aiDataDb.run("INSERT INTO memories (task_id, prompt, response, proof_state) VALUES (?, ?, ?, ?)", [this.taskId, prompt, response, proofState]);
    }

    saveBlob(proj, file, content) { blobsDb.run("INSERT INTO blobs (project_name, file_path, content) VALUES (?, ?, ?)", [proj, path.basename(file), content]); }
    logEvent(type, msg) { aiDataDb.run("INSERT INTO events (event_type, message) VALUES (?, ?)", [type, msg]); }

    gitCommit(projectName) {
        // Use the project directory for git operations
        exec(`git -C ${AI_HOME} add . && git -C ${AI_HOME} commit -m "feat: AI project ${projectName}"`, (err, stdout, stderr) => {
            if (err) this.logEvent('GIT_ERROR', `Failed to commit ${projectName}: ${stderr}`);
            else this.logEvent('GIT_SUCCESS', `Committed project ${projectName}`);
        });
    }

    async execute() {
        this.logEvent('ORCHESTRATION_START', `Task ${this.taskId} started.`);
        const finalOutput = await this.recursiveConsensus();
        console.log("\n\x1b[1;36m--- Final Consensus Output ---\x1b[0m\n");
        console.log(finalOutput);
        this.saveMemory(this.initialPrompt, finalOutput);
        await this.handleCodeGeneration(finalOutput);
        this.logEvent('ORCHESTRATION_END', `Task ${this.taskId} finished.`);
    }
}

(async () => {
    const args = process.argv.slice(2);
    // Find the first argument that doesn't start with '--' and treat it as the prompt start
    const promptParts = args.filter(arg => !arg.startsWith('--'));
    const prompt = promptParts.join(' ');
    
    // Extract options (flags)
    const options = Object.fromEntries(args.filter(arg => arg.startsWith('--')).map(arg => arg.slice(2).split('=')));
    
    if (!prompt) process.exit(1);

    const orchestrator = new AIOrchestrator(prompt, options);
    await orchestrator.execute().finally(() => {
        aiDataDb.close();
        blobsDb.close();
    });
})();
EOF

    # Write the Python Webserver, Wallet, and Seed Manager
    cat > "$AI_HOME/manager.py" << 'EOF'
import http.server, socketserver, json, sqlite3, os, sys, argparse

try:
    from bip_utils import Bip39SeedGenerator, Bip44, Bip44Coins
    BIP_UTILS_AVAILABLE = True
except ImportError:
    # This dependency is optional but provides core wallet functionality
    BIP_UTILS_AVAILABLE = False

AI_HOME = os.path.expanduser("~/.sysop-ai")
DB_DIR = os.path.join(AI_HOME, "db")
WALLET_DB_PATH = os.path.join(DB_DIR, "wallet.db")

def setup_wallet_db():
    os.makedirs(DB_DIR, exist_ok=True)
    conn = sqlite3.connect(WALLET_DB_PATH)
    c = conn.cursor()
    c.execute('CREATE TABLE IF NOT EXISTS seeds (id INTEGER PRIMARY KEY, mnemonic TEXT UNIQUE)')
    c.execute('CREATE TABLE IF NOT EXISTS wallets (id INTEGER PRIMARY KEY, name TEXT, coin_type TEXT, address TEXT, private_key TEXT)')
    conn.commit()
    conn.close()

def manage_seed(action):
    if not BIP_UTILS_AVAILABLE:
        print("Error: 'bip_utils' library not found. Please run 'pip install bip-utils'", file=sys.stderr)
        return
    setup_wallet_db()
    conn = sqlite3.connect(WALLET_DB_PATH)
    c = conn.cursor()
    if action == 'generate':
        # Generate a 12-word seed
        mnemonic = Bip39SeedGenerator.FromWordsNumber(12).Generate()
        try:
            c.execute("INSERT INTO seeds (mnemonic) VALUES (?)", (mnemonic,))
            conn.commit()
            print(f"Generated and saved new seed: {mnemonic}")
        except sqlite3.IntegrityError:
            print("Generated a duplicate seed, which is highly unlikely. Try again.")
    elif action == 'list':
        for row in c.execute("SELECT id, mnemonic FROM seeds"):
            print(f"ID {row[0]}: {row[1]}")
    conn.close()

def manage_wallet(action, name="default"):
    # Wallet management logic would go here
    print(f"Wallet action '{action}' for wallet '{name}' is not fully implemented yet.")

class APIHandler(http.server.SimpleHTTPRequestHandler):
    # Minimal JSON response for status check
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({"status": "SysOp-AI Server is running"}).encode())

def run_server():
    PORT = 8000
    with socketserver.TCPServer(("", PORT), APIHandler) as httpd:
        print(f"Serving at http://localhost:{PORT}")
        httpd.serve_forever()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="SysOp-AI Manager")
    subparsers = parser.add_subparsers(dest='command')
    
    server_parser = subparsers.add_parser('server', help='Run the web server')
    
    seed_parser = subparsers.add_parser('seed', help='Manage seed phrases')
    seed_parser.add_argument('action', choices=['generate', 'list'])
    
    wallet_parser = subparsers.add_parser('wallet', help='Manage wallets')
    wallet_parser.add_argument('action', choices=['create', 'list'])
    wallet_parser.add_argument('--name', default='default')
    
    args = parser.parse_args()
    
    if args.command == 'server':
        run_server()
    elif args.command == 'seed':
        manage_seed(args.action)
    elif args.command == 'wallet':
        manage_wallet(args.action, args.name)
EOF

    # Initialize Databases
    sqlite3 "$AI_DATA_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY, task_id TEXT, prompt TEXT, response TEXT, proof_state TEXT, ts DATETIME DEFAULT CURRENT_TIMESTAMP);" &>/dev/null
    sqlite3 "$AI_DATA_DB" "CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY, event_type TEXT, message TEXT, ts DATETIME DEFAULT CURRENT_TIMESTAMP);" &>/dev/null
    sqlite3 "$BLOBS_DB" "CREATE TABLE IF NOT EXISTS blobs (id INTEGER PRIMARY KEY, project_name TEXT, file_path TEXT, content BLOB, ts DATETIME DEFAULT CURRENT_TIMESTAMP);" &>/dev/null
    
    # Initialize Git Repo
    if [ ! -d "$AI_HOME/.git" ]; then
        git init -b devel "$AI_HOME" &>/dev/null
        log_event "INFO" "Initialized Git repository in $AI_HOME"
    fi
}

# Log an event to console and DB
log_event() {
    # Escape single quotes in the message for safe sqlite insertion
    local safe_msg=$(echo "$2" | sed "s/'/''/g")
    echo "[\x1b[34m$1\x1b[0m] $(date): $2"
    sqlite3 "$AI_DATA_DB" "INSERT INTO events (event_type, message) VALUES ('$1', '$safe_msg');"
}

# Display help message
show_help() {
    echo "SysOp-AI: A self-contained AI orchestration framework."
    echo ""
    echo "USAGE:"
    echo "  ai <prompt> [FLAGS]     (Default behavior: runs the prompt as an AI task)"
    echo "  ai [COMMAND] [ARGUMENTS]"
    echo ""
    echo "DEFAULT BEHAVIOR:"
    echo "  If a command is not recognized, it is treated as a prompt and executed via 'run'."
    echo ""
    echo "COMMANDS:"
    echo "  run <prompt>        Run an AI task loop with the given prompt."
    echo "  import <url>        Pull external content to provide context for a run."
    echo "  memories            Show past AI prompts/responses."
    echo "  events              Show event logs."
    echo "  blobs               List stored file blobs."
    echo "  ssh-key [ls|gen]    Manage SSH keys."
    echo "  seed [generate|list] Manage wallet seed phrases."
    echo "  wallet [create|list] Manage wallets (not fully implemented)."
    echo "  server              Start the Python web server (runs in background)."
    echo "  status              Show environment, tools, and model statuses."
    echo "  --start             Interactively start a new named project session."
    echo "  --stop              Stop the current project session."
    echo "  --help              Show this help message."
    echo ""
    echo "FLAGS (apply to 'run' or default prompt):"
    echo "  --project=<name>    Assign a name to the project for generated files."
}

# Default action: hash timestamp and list files (only runs if $# is 0)
default_task() {
    echo "No command or prompt provided. Performing default task."
    local timestamp=$(date +%s)
    local hash=$(echo -n "$timestamp" | sha256sum | awk '{print $1}')
    echo "Timestamp: $timestamp"
    echo "Hash: $hash"
    echo "Files in current directory (recursive):"
    find . -type f
}

# Manage SSH Keys
manage_ssh() {
    case "$1" in
        ls) ls -la "$SSH_DIR" ;;
        gen)
            read -p "Enter key name (e.g., id_rsa_project): " key_name
            ssh-keygen -t rsa -b 4096 -f "$SSH_DIR/$key_name"
            log_event "SSH" "Generated new key: $key_name"
            ;;
        *) echo "Usage: ai ssh-key [ls|gen]" ;;
    esac
}

# --- Shared Run Logic Function ---
# Takes the full prompt string (including flags) as argument 1
execute_ai_run() {
    local prompt="$1"
    
    # Session handling: Append --project flag if a session is active
    if [ -f "$SESSION_FILE" ]; then
        local proj_name=$(cat "$SESSION_FILE")
        # Only append if the project flag wasn't already provided in the prompt
        if ! [[ "$prompt" =~ --project= ]]; then
            prompt="$prompt --project=$proj_name"
        fi
    fi
    
    log_event "TASK_START" "Prompt: $prompt"
    
    # CRITICAL FIX: Set NODE_PATH to ensure Node can find local 'sqlite3' dependency
    NODE_PATH="$AI_HOME/node_modules" node "$AI_HOME/orchestrator.js" "$prompt"
    
    log_event "TASK_END" "Task finished."
}

# --- Main Execution ---
# Check dependencies (including npm) and set up environment (including npm install)
check_dependencies
setup_environment

# If no arguments, run default task
if [ $# -eq 0 ]; then
    default_task
    exit 0
fi

# The first argument is the potential command.
COMMAND="$1"

case "$COMMAND" in
    --start)
        read -p "Enter project/repo name: " proj_name
        echo "$proj_name" > "$SESSION_FILE"
        log_event "SESSION" "Started session for project '$proj_name'"
        ;;
    --stop)
        rm -f "$SESSION_FILE"
        log_event "SESSION" "Stopped session."
        ;;
    run)
        shift # Remove 'run' command
        # Use the remaining arguments as the prompt
        execute_ai_run "$@"
        ;;
    import)
        shift # Remove 'import' command
        URL="$1"
        shift # Remove URL
        CONTENT=$(curl -sL "$URL")
        log_event "IMPORT" "Importing content from $URL"
        echo "Import complete. The following content will be used as context for your next 'run' command:"
        echo "---"
        echo "${CONTENT:0:500}..."
        echo "---"
        # Run orchestrator with imported content as prompt
        NODE_PATH="$AI_HOME/node_modules" node "$AI_HOME/orchestrator.js" "Summarize and analyze the following content: $CONTENT"
        ;;
    memories) sqlite3 -header -column "$AI_DATA_DB" "SELECT id, task_id, substr(prompt, 1, 40) as prompt, ts FROM memories ORDER BY ts DESC;" ;;
    events) sqlite3 -header -column "$AI_DATA_DB" "SELECT * FROM events ORDER BY ts DESC;" ;;
    blobs) sqlite3 -header -column "$BLOBS_DB" "SELECT id, project_name, file_path, length(content) as size, ts FROM blobs ORDER BY ts DESC;" ;;
    ssh-key) 
        shift 
        manage_ssh "$@" 
        ;;
    seed) 
        shift
        python3 "$AI_HOME/manager.py" seed "$@" 
        ;;
    wallet) 
        shift 
        python3 "$AI_HOME/manager.py" wallet "$@" 
        ;;
    server) python3 "$AI_HOME/manager.py" server & ;;
    status)
        echo "SysOp-AI Status"
        echo "AI_HOME: $AI_HOME"
        echo "Ollama: $(command -v $OLLAMA_BIN &> /dev/null && echo 'OK' || echo 'Not Found')"
        echo "SQLite: $(command -v sqlite3 &> /dev/null && echo 'OK' || echo 'Not Found')"
        echo "NodeJS: $(command -v node &> /dev/null && echo 'OK' || echo 'Not Found')"
        echo "Python3: $(command -v python3 &> /dev/null && echo 'OK' || echo 'Not Found')"
        [ -f "$SESSION_FILE" ] && echo "Active Session: $(cat "$SESSION_FILE")"
        ;;
    --help|-h) show_help ;;
    *) # Default behavior: Treat all arguments as the prompt and execute 'run' logic
        # $COMMAND is the first word of the prompt, and $@ is the entire prompt.
        execute_ai_run "$@"
        ;;
esac