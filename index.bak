<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nemodian 2244-1 :: Quantum Fractal AI Editor (20-Step Protocol)</title>
    <style>
        :root {
            --muted: #888;
            --info: #2196F3;
            --warn: #FF9800;
            --error: #F44336;
            --success: #4CAF50;
            --baseline: 1.5em;
            --header-h: calc(var(--baseline) * 1.6);
            --status-h: var(--baseline);
            --footer-h: calc(var(--baseline) * 2);
            --font-size: 13px;
            --ln-width: 50px;
            --theme-bg: #3a3c31;
            --panel: #313328;
            --header-bg: #2e3026;
            --status-bg: #22241e;
            --accent: #4ac94a;
            --muted-text: #999966;
            --err: #a03333;
            --warn-bg: #f0ad4e;
            --hover-blue: #3366a0;
            --info-bg: #5bc0de;
            --agent-nexus: #BB86FC; /* core */
            --agent-cognito: #03DAC6; /* loop */
            --agent-relay: #FFD54F; /* 2244 */
            --agent-sentinel: #CF6679; /* coin */
            --agent-echo: #4ac94a; /* code */
            --quantum-glow: rgba(187, 134, 252, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', monospace;
            font-size: var(--font-size);
            line-height: var(--baseline);
            background: var(--theme-bg);
            color: #f0f0e0;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-rows: var(--header-h) var(--status-h) 1fr var(--footer-h);
        }

        header {
            grid-row: 1;
            grid-column: 1 / -1;
            background: var(--header-bg);
            border-bottom: 1px solid #22241e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--quantum-glow), transparent);
            animation: quantumScan 3s infinite linear;
        }

        @keyframes quantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .quantum-pulse {
            animation: quantumPulse 2s infinite alternate;
        }

        .typing-active {
            caret-color: lime;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { background-color: transparent; }
            51%, 100% { background-color: rgba(0,255,0,0.05); }
        }

        @keyframes quantumPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        header .left {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        header .right {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        button {
            background: var(--err);
            border: 1px solid var(--err);
            color: #f0f0e0;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all .2s;
            border-radius: 3px;
        }

        button:hover {
            background: var(--hover-blue);
            border-color: var(--hover-blue);
        }

        button.success {
            background: var(--accent);
            border-color: var(--accent);
        }

        button.info {
            background: var(--info-bg);
            border-color: var(--info-bg);
        }

        button.warn {
            background: var(--warn-bg);
            border-color: var(--warn-bg);
            color: #3a3c31;
        }

        #status-bar {
            grid-row: 2;
            grid-column: 1 / -1;
            background: var(--status-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px;
            font-size: 12px;
            position: relative;
        }

        .quantum-threads {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .quantum-thread {
            position: absolute;
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--agent-nexus), transparent);
            animation: threadFlow 2s infinite linear;
        }

        @keyframes threadFlow {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        #editor-stage {
            grid-row: 3;
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 0px 1fr;
            background: var(--theme-bg);
            overflow: hidden;
            position: relative;
            transition: grid-template-columns 0.3s ease;
        }

        #editor-stage.left-panel-open {
            grid-template-columns: 240px 1fr;
        }

        #left-panel {
            background: var(--panel);
            border-right: 1px solid #22241e;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            width: 240px;
        }

        .editor-container {
            position: relative;
            display: flex;
            flex: 1;
            background: var(--theme-bg);
            overflow: auto;
        }

        .line-numbers {
            width: var(--ln-width);
            padding: 10px 8px;
            background: var(--panel);
            color: var(--muted-text);
            font-variant-numeric: tabular-nums;
            text-align: right;
            user-select: none;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .editor-content {
            flex: 1;
            position: relative;
            min-height: 100%;
            padding: 10px;
            padding-left: 12px;
            box-sizing: border-box;
            white-space: pre;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            tab-size: 4;
            -moz-tab-size: 4;
            caret-color: var(--accent);
            outline: none;
            overflow-wrap: normal;
            word-break: normal;
            overflow: auto;
        }

        .editor-content:focus {
            outline: none;
        }

        footer {
            grid-row: 4;
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: var(--header-bg);
            border-top: 1px solid #22241e;
            position: sticky;
            bottom: 0;
        }

        #prompt-input {
            flex: 1;
            margin-right: 8px;
            padding: 8px;
            background: var(--status-bg);
            border: 1px solid var(--accent);
            color: #f0f0e0;
            font-family: inherit;
            border-radius: 3px;
            font-size: 16px;
        }

        .small {
            font-size: 12px;
            padding: 6px 8px;
        }

        .agent-card {
            background: var(--panel);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid var(--muted-text);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .agent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .agent-card.active::before {
            left: 100%;
        }

        .agent-card.active {
            box-shadow: 0 0 20px var(--quantum-glow);
            transform: translateY(-2px);
        }

        .agent-card.nexus { border-left-color: var(--agent-nexus); }
        .agent-card.cognito { border-left-color: var(--agent-cognito); }
        .agent-card.relay { border-left-color: var(--agent-relay); }
        .agent-card.sentinel { border-left-color: var(--agent-sentinel); }
        .agent-card.echo { border-left-color: var(--agent-echo); }

        .agent-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .agent-nexus .agent-title { color: var(--agent-nexus); }
        .agent-cognito .agent-title { color: var(--agent-cognito); }
        .agent-relay .agent-title { color: var(--agent-relay); }
        .agent-sentinel .agent-title { color: var(--agent-sentinel); }
        .agent-echo .agent-title { color: var(--agent-echo); }

        .agent-subtitle {
            font-size: 11px;
            color: var(--muted-text);
            margin-bottom: 6px;
        }

        .agent-content {
            font-size: 12px;
            line-height: 1.4;
            min-height: 20px;
        }

        .quantum-spinner {
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            position: relative;
        }

        .quantum-spinner::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid var(--agent-cognito);
            border-radius: 50%;
            animation: quantumSpin 1s linear infinite;
        }

        .quantum-spinner::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-bottom: 2px solid var(--agent-nexus);
            border-radius: 50%;
            animation: quantumSpin 0.5s linear infinite;
        }

        @keyframes quantumSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quantum-packet {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--agent-nexus);
            box-shadow: 0 0 10px var(--agent-nexus);
            opacity: 0;
            z-index: 100;
            pointer-events: none;
        }

        .quantum-trail {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--agent-nexus), transparent);
            opacity: 0;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--muted-text);
        }

        .action-buttons button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .quantum-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin-top: 5px;
        }

        .quantum-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--muted-text);
            position: relative;
        }

        .quantum-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 1px solid var(--agent-nexus);
            animation: quantumPulseDot 2s infinite;
        }

        .quantum-dot.connected {
            background: var(--accent);
        }

        @keyframes quantumPulseDot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* ========== SYNTAX HIGHLIGHTING STYLES ========== */
        .sh-token { transition: opacity 0.08s ease; pointer-events: none; }
        .sh-comment { color: #64748b; font-style: italic; opacity: 0.8; }
        .sh-string { color: #a3e635; font-weight: 500; }
        .sh-number { color: #f59e0b; font-weight: 600; }
        .sh-keyword { color: #f472b6; font-weight: 600; }
        .sh-type { color: #7dd3fc; font-weight: 500; }
        .sh-bracket { color: #c084fc; font-weight: 700; }
        .sh-id { color: #94a3b8; }
        .sh-op { color: #94a3b8; font-weight: 500; }
        .sh-ws { opacity: 0.3; }
        .sh-key { color: #7dd3fc; font-weight: 500; }
        .sh-number2 { color: #f59e0b; font-weight: 600; }
        .sh-text { color: #e2e8f0; }
        .sh-unknown { color: #f87171; }
        .sh-tag { color: #f472b6; font-weight: 600; }
        .sh-property { color: #7dd3fc; font-weight: 500; }
        .sh-function { color: #4ac94a; font-weight: 500; }
        .sh-operator { color: #93c5fd; font-weight: 600; }
        .sh-regex { color: #fbbf24; }
        .sh-html-entity { color: #f59e0b; }
        .sh-css-selector { color: #c084fc; }
        .sh-css-property { color: #60a5fa; }
        .sh-css-value { color: #34d399; }
        .sh-jsx-tag { color: #f472b6; }
        .sh-jsx-attribute { color: #7dd3fc; }
        .sh-template-string { color: #a3e635; font-weight: 500; }

        .editor-content::selection {
            background: rgba(74, 201, 74, 0.3);
        }

        .editor-container::-webkit-scrollbar {
            width: 12px;
        }

        .editor-container::-webkit-scrollbar-track {
            background: var(--panel);
        }

        .editor-container::-webkit-scrollbar-thumb {
            background: var(--muted-text);
            border-radius: 6px;
        }

        .editor-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        #preview-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 5px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,.7);
        }

        #preview-header {
            background: var(--header-bg);
            color: #f0f0e0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--accent);
        }

        #preview-content {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background: white;
        }

        #close-preview {
            background: transparent;
            border: none;
            color: #f0f0e0;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ai-response-panel {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 500px;
            max-height: 600px;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,.3);
        }

        #ai-response-content {
            font-size: 12px;
            line-height: 1.4;
        }

        #close-ai-panel {
            position: absolute;
            top: 5px;
            right: 5px;
            background: transparent;
            border: none;
            color: var(--muted-text);
            font-size: 14px;
            cursor: pointer;
        }

        #file-input {
            display: none;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: none;
        }

        .ai-dot.probing {
            background: var(--err);
            animation: pulse 2s infinite;
        }

        .ai-dot.connected {
            background: var(--accent);
            animation: none;
        }

        .quantum-thinking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .fractal-node {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--agent-cognito);
            animation: fractalPulse 1.5s infinite alternate;
        }

        @keyframes fractalPulse {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(1.5); opacity: 0.8; }
        }

        @media (max-width: 768px) {
            #editor-stage {
                grid-template-columns: 1fr !important;
            }

            #left-panel {
                position: absolute;
                height: 100%;
                z-index: 30;
                transform: translateX(-240px);
            }

            #left-panel.open {
                transform: translateX(0);
            }

            #ai-response-panel {
                width: calc(100% - 40px);
                right: 20px;
            }

            #preview-panel {
                width: 95%;
                height: 85%;
            }

            body {
                grid-template-rows: var(--header-h) var(--status-h) 1fr auto;
            }

            footer {
                position: relative;
            }
        }

        .consensus-panel {
            background: var(--panel);
            border: 1px solid var(--agent-nexus);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .consensus-header {
            font-weight: bold;
            color: var(--agent-nexus);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .candidate-item {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--agent-cognito);
        }

        .candidate-meta {
            font-size: 10px;
            color: var(--muted-text);
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .candidate-content {
            font-size: 11px;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            max-height: 80px;
            overflow: hidden;
        }

        .entropy-badge {
            background: var(--agent-nexus);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        .selected-candidate {
            border-left-color: var(--accent);
            background: rgba(74, 201, 74, 0.1);
        }

        .orchestration-log {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Fira Code', monospace;
        }

        .orchestration-log .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid var(--agent-nexus);
        }

        .orchestration-log .log-entry.genesis {
            border-left-color: var(--agent-nexus);
            color: var(--agent-nexus);
        }

        .orchestration-log .log-entry.origin {
            border-left-color: var(--agent-cognito);
            color: var(--agent-cognito);
        }

        .orchestration-log .log-entry.event {
            border-left-color: var(--agent-relay);
            color: var(--agent-relay);
        }

        .orchestration-log .log-entry.fragment {
            border-left-color: var(--agent-sentinel);
            color: var(--agent-sentinel);
        }

        .orchestration-log .log-entry.consensus {
            border-left-color: var(--agent-echo);
            color: var(--agent-echo);
        }

        .memory-status {
            font-size: 10px;
            color: var(--muted-text);
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0,0,0,0.3);
        }

        .memory-status.low {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .memory-status.warning {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .memory-status.good {
            color: #4ac94a;
        }

        .suggestion-item {
            padding: 8px;
            border-bottom: 1px solid var(--muted-text);
            cursor: pointer;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        #suggestions-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .collaboration-controls {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "fs": "https://aistudiocdn.com/fs@^0.0.1-security",
    "path": "https://aistudiocdn.com/path@^0.12.7",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.29.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
  }
}
</script>
</head>
<body>
<header>
    <div class="left">
        <button id="left-toggle" class="small">‚ò∞</button>
        <div style="font-weight:800;" class="quantum-pulse">Nemodian 2244-1 :: Quantum Fractal AI (20-Step Protocol)</div>
    </div>
    <div class="right">
        <div class="ai-status">
            <div id="ai-dot" class="ai-dot connected"></div>
            <div id="ai-indicator" style="font-size:12px;color:#cfcfbd;">Quantum AI: Enhanced</div>
        </div>
        <button id="open-file" class="small">Open</button>
        <button id="save-file" class="small">Save</button>
        <button id="save-as" class="small">Save As</button>
        <button id="render-html" class="small warn">Render HTML</button>
        <button id="run-local-ai" class="small info">Quantum AI</button>
        <button id="run-orchestrator" class="small success">20-Step Orchestrator</button>
    </div>
</header>
<div id="status-bar" class="info">
    <div class="quantum-threads" id="quantum-threads"></div>
    <div id="file-meta">No File Loaded</div>
    <div id="editor-meta">Cursor: 0:0 | Lines: 0 | Chars: 0 | History: 0</div>
    <div id="memory-status" class="memory-status good">RAM: OK</div>
</div>
<div id="editor-stage">
    <aside id="left-panel" class="closed">
        <button id="btn-undo" class="small">UNDO</button>
        <button id="btn-redo" class="small">REDO</button>
        <button id="btn-beautify" class="small">Beautify</button>
        <button id="btn-render" class="small warn">Render HTML</button>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum AI Commands:</strong></p>
            <ul style="padding-left: 15px;">
                <li>Rewrite this function</li>
                <li>Optimize performance</li>
                <li>Add error handling</li>
                <li>Convert to TypeScript</li>
                <li>Explain this code</li>
            </ul>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Actions:</strong></p>
            <button id="btn-optimize" class="small" style="width:100%;margin-bottom:5px;">Quantum Optimize</button>
            <button id="btn-document" class="small" style="width:100%;margin-bottom:5px;">Fractal Document</button>
            <button id="btn-refactor" class="small" style="width:100%;">Hyper Refactor</button>
            <button id="btn-orchestrate" class="small success" style="width:100%;margin-top:5px;">20-Step Orchestrate</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Memory Management:</strong></p>
            <button id="btn-clear-cache" class="small" style="width:100%;margin-bottom:5px;">Clear Cache</button>
            <button id="btn-optimize-memory" class="small info" style="width:100%;margin-bottom:5px;">Optimize Memory</button>
            <button id="btn-export-session" class="small" style="width:100%;">Export Session</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Settings:</strong></p>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <input type="checkbox" id="quantum-mode" checked>
                <label for="quantum-mode">Quantum Fractal Mode</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="hyperthreading" checked>
                <label for="hyperthreading">Hyperthreading</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="multi-agent-mode" checked>
                <label for="multi-agent-mode">Multi-Agent Consensus</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="auto-save" checked>
                <label for="auto-save">Auto Save</label>
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Orchestrator Settings:</strong></p>
            <div style="margin-bottom: 5px;">
                <label for="agent-count">Agent Count:</label>
                <input type="number" id="agent-count" min="2" max="5" value="5" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="max-rounds">Max Rounds:</label>
                <input type="number" id="max-rounds" min="1" max="5" value="2" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="reasoning-depth">Reasoning Depth:</label>
                <input type="number" id="reasoning-depth" min="1" max="3" value="2" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Recent Files:</strong></p>
            <div id="recent-files" style="max-height: 100px; overflow-y: auto;">
                <!-- Recent files will be populated here -->
            </div>
        </div>
    </aside>

    <!-- Quantum Editor Container -->
    <div class="editor-container">
        <div class="quantum-thinking" id="quantum-thinking"></div>
        <div class="line-numbers" id="line-numbers"></div>
        <div
            class="editor-content"
            id="editor"
            contenteditable="true"
            spellcheck="false"
            data-gramm="false"
            data-gramm_editor="false"
            data-enable-grammarly="false"
        >// Enhanced Quantum Fractal AI Editor - Ready
// Start coding or use the prompt below for AI assistance

function welcome() {
    return "Welcome to the Enhanced Quantum Fractal AI Editor!";
}</div>
    </div>
</div>
<footer>
    <input id="prompt-input" placeholder="Enter 20-Step quantum command (e.g., 'rewrite the welcome function for security')">
    <button id="send-button" class="success">20-STEP QUANTUM PROCESS</button>
</footer>

<!-- Hidden elements -->
<input type="file" id="file-input" accept=".js,.html,.css,.txt,.json,.ts,.jsx,.tsx,.py,.php,.sql,.md,.xml,.yaml,.yml">
<div id="suggestions-panel"></div>

<!-- Panels -->
<div id="preview-panel">
    <div id="preview-header">
        <span>Quantum Preview</span>
        <button id="close-preview">√ó</button>
    </div>
    <iframe id="preview-content"></iframe>
</div>

<div id="ai-response-panel">
    <button id="close-ai-panel">√ó</button>
    <div id="ai-response-content">
        <div class="agent-card nexus agent-nexus">
            <div class="agent-title">Nexus (Core)</div>
            <div class="agent-subtitle">Enhanced Quantum Orchestrator (P1: Genesis Foundation)</div>
            <div class="agent-content">Idle. Awaiting 20-Step command.</div>
            <div class="orchestration-log" id="nexus-log"></div>
            <div class="quantum-status">
                <div class="quantum-dot connected"></div>
                <span>Quantum State: Entangled</span>
            </div>
        </div>
        <div class="agent-card cognito agent-cognito">
            <div class="agent-title">Cognito (Loop)</div>
            <div class="agent-subtitle">Enhanced Fractal Analyzer (P2: Collaborative Acceleration)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="cognito-log"></div>
        </div>
        <div class="agent-card relay agent-relay">
            <div class="agent-title">Relay (2244)</div>
            <div class="agent-subtitle">Enhanced Quantum Communicator (P3: Backtraced Finalization)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="relay-log"></div>
        </div>
        <div class="agent-card sentinel agent-sentinel">
            <div class="agent-title">Sentinel (Coin)</div>
            <div class="agent-subtitle">Enhanced Quantum Validator (All Phases: Hashing, Security, Entropy)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="sentinel-log"></div>
        </div>
        <div class="agent-card echo agent-echo">
            <div class="agent-title">Echo (Code)</div>
            <div class="agent-subtitle">Enhanced Quantum Synthesizer (All Phases: Reasoning, Quality, Docs)</div>
            <div class="agent-content">Awaiting quantum report...</div>
            <div class="orchestration-log" id="echo-log"></div>
        </div>
        <div class="consensus-panel" id="consensus-panel" style="display: none;">
            <div class="consensus-header">
                <span>20-Step Protocol Final Metrics</span>
                <span class="entropy-badge" id="consensus-score">Score: 0</span>
            </div>
            <div id="candidates-list"></div>
        </div>
    </div>
</div>

<script>
<script>
    /* =========================================================================
       Enhanced 20-Step Quantum Orchestration Protocol Implementation
       ========================================================================== */

    class EnhancedQuantumOrchestrator {
        constructor() {
            this.agents = {
                nexus: document.querySelector('.agent-nexus .agent-content'),
                cognito: document.querySelector('.agent-cognito .agent-content'),
                relay: document.querySelector('.agent-relay .agent-content'),
                sentinel: document.querySelector('.agent-sentinel .agent-content'),
                echo: document.querySelector('.agent-echo .agent-content')
            };

            this.logElements = {
                nexus: document.getElementById('nexus-log'),
                cognito: document.getElementById('cognito-log'),
                relay: document.getElementById('relay-log'),
                sentinel: document.getElementById('sentinel-log'),
                echo: document.getElementById('echo-log')
            };

            this.agentCards = {
                nexus: document.querySelector('.agent-nexus'),
                cognito: document.querySelector('.agent-cognito'),
                relay: document.querySelector('.agent-relay'),
                sentinel: document.querySelector('.agent-sentinel'),
                echo: document.querySelector('.agent-echo')
            };

            this.consensusPanel = document.getElementById('consensus-panel');
            this.candidatesList = document.getElementById('candidates-list');
            this.consensusScore = document.getElementById('consensus-score');

            this.isGenerating = false;
            this.quantumConnected = false;
            
            // 20-Step Protocol Configuration
            this.agentCount = 5;
            this.maxRounds = 3;
            this.reasoningDepth = 3;

            // File system for 20-step protocol
            this.fileSystem = {
                genesisHash: null,
                genesisCounter: 0,
                eventLog: [],
                fragments: [],
                origins: {},
                tokenPool: [],
                collaborationGraph: new Map()
            };

            this.orchestrationState = {
                currentPhase: 'Genesis Foundation',
                currentStep: 0,
                activeAgents: new Set(),
                consensusThreshold: 0.8,
                collaborationIntensity: 0.5,
                agentData: {},
                metrics: {}
            };

            this.bindOrchestratorEvents();
        }

        bindOrchestratorEvents() {
            // Main orchestrator button
            document.getElementById('run-orchestrator').addEventListener('click', () => {
                this.run20StepProtocol();
            });

            // Sidebar orchestrator button
            document.getElementById('btn-orchestrate').addEventListener('click', () => {
                this.run20StepProtocol();
            });

            // Settings bindings
            document.getElementById('agent-count').addEventListener('change', (e) => {
                this.agentCount = parseInt(e.target.value);
            });

            document.getElementById('max-rounds').addEventListener('change', (e) => {
                this.maxRounds = parseInt(e.target.value);
            });

            document.getElementById('reasoning-depth').addEventListener('change', (e) => {
                this.reasoningDepth = parseInt(e.target.value);
            });

            console.log('Orchestrator events bound successfully');
        }

        async run20StepProtocol() {
            if (this.isGenerating) {
                quantumNotify('Protocol already running...', 'warn');
                return;
            }

            this.isGenerating = true;
            const promptInput = document.getElementById('prompt-input');
            const promptText = promptInput.value.trim() || "Execute 20-step quantum protocol for code generation";
            const editorContext = quantumEditor.getContent();

            // Show AI panel
            document.getElementById('ai-response-panel').style.display = 'block';
            this.resetOrchestrationUI();

            try {
                this.orchestrationState.prompt = promptText;
                let allFragments = [];
                let finalAnswer = {};
                let finalCode = '';

                // ===================================
                // PHASE 1: GENESIS FOUNDATION (Steps 1-5)
                // ===================================
                this.orchestrationState.currentPhase = 'Genesis Foundation';
                
                // STEP 1: Universal Genesis Hash Generation
                await this.addLog('nexus', 'üöÄ STEP 1: Generating Universal Genesis Hash...', 'genesis');
                const genesisHash = await this.step1_GenesisHashGeneration(promptText);
                
                // STEP 2: Agent-Specific Origin Hash Creation
                await this.addLog('cognito', 'üë• STEP 2: Creating Agent Origin Hashes...', 'origin');
                await this.step2_AgentOriginHashCreation(genesisHash);
                
                // STEP 3: Natural Language Prompt Deconstruction
                await this.addLog('relay', '‚è±Ô∏è STEP 3: Deconstructing Natural Language Prompt...', 'event');
                const timestampIndexer = await this.step3_PromptDeconstruction(promptText, genesisHash);
                
                // STEP 4: Parallel Fractal Quantum Reasoning
                await this.addLog('sentinel', '‚ö° STEP 4: Initiating Parallel Fractal Reasoning...', 'fragment');
                allFragments = await this.step4_ParallelFractalReasoning(promptText, editorContext, timestampIndexer);
                
                // STEP 5: Genesis-Counter Memory Staging
                await this.addLog('nexus', 'üîÑ STEP 5: Staging Memory with Genesis Counter...', 'genesis');
                await this.step5_GenesisCounterMemoryStaging(allFragments);

                // ===================================
                // PHASE 2: COLLABORATIVE ACCELERATION (Steps 6-10)
                // ===================================
                this.orchestrationState.currentPhase = 'Collaborative Acceleration';
                
                // STEP 6: Entropy-Based Reasoning Acceleration
                await this.addLog('cognito', '‚¨ÜÔ∏è STEP 6: Accelerating Reasoning via Entropy...', 'origin');
                allFragments = this.step6_EntropyBasedReasoningAcceleration(allFragments);
                
                // STEP 7: Multi-Agent Collaboration Enforcement
                await this.addLog('cognito', 'ü§ù STEP 7: Enforcing Multi-Agent Collaboration...', 'origin');
                allFragments = this.step7_MultiAgentCollaborationEnforcement(allFragments);
                
                // STEP 8: Realstream Thinking Injection
                await this.addLog('relay', 'üíæ STEP 8: Injecting Realstream Thinking...', 'event');
                await this.step8_RealstreamThinkingInjection(allFragments, timestampIndexer);
                
                // STEP 9: Final Answer Sourcing & Validation
                await this.addLog('echo', 'üöÄ STEP 9: Sourcing Final Answer...', 'consensus');
                finalAnswer = await this.step9_FinalAnswerSourcingValidation(allFragments);
                
                // STEP 10: Cyclic Math-Based Token Integration
                await this.addLog('echo', 'üî¢ STEP 10: Integrating Cyclic Math Tokens...', 'consensus');
                finalCode = await this.step10_CyclicTokenIntegration(finalAnswer.bestCandidate);

                // ===================================
                // PHASE 3: BACKTRACED FINALIZATION (Steps 11-20)
                // ===================================
                this.orchestrationState.currentPhase = 'Backtraced Finalization';
                
                // STEP 11: Genesis Chain Verification
                await this.addLog('nexus', 'üîí STEP 11: Verifying Genesis Chain Integrity...', 'genesis');
                await this.step11_GenesisChainVerification(allFragments);
                
                // STEP 12: Multi-Dimensional Entropy Analysis
                await this.addLog('sentinel', 'üìà STEP 12: Analyzing Multi-Dimensional Entropy...', 'fragment');
                this.orchestrationState.metrics.entropyAnalysis = await this.step12_MultiDimensionalEntropyAnalysis(allFragments);
                
                // STEP 13: Collaborative Consensus Scoring
                await this.addLog('cognito', 'ü§ù STEP 13: Scoring Collaborative Consensus...', 'origin');
                this.orchestrationState.metrics.consensus = await this.step13_CollaborativeConsensusScoring(allFragments);
                
                // STEP 14: Prompt-Answer Alignment Verification
                await this.addLog('relay', 'üí¨ STEP 14: Verifying Prompt-Answer Alignment...', 'event');
                this.orchestrationState.metrics.alignment = await this.step14_PromptAnswerAlignmentVerification(finalCode, promptText);
                
                // STEP 15: Code Quality & Syntax Validation
                await this.addLog('echo', 'üìê STEP 15: Validating Code Quality & Syntax...', 'consensus');
                this.orchestrationState.metrics.quality = await this.step15_CodeQualitySyntaxValidation(finalCode);
                
                // STEP 16: Performance Optimization Layer
                await this.addLog('sentinel', '‚ö° STEP 16: Applying Performance Optimization...', 'fragment');
                finalCode = await this.step16_PerformanceOptimizationLayer(finalCode);
                
                // STEP 17: Security & Vulnerability Assessment
                await this.addLog('sentinel', 'üõ°Ô∏è STEP 17: Assessing Security & Vulnerabilities...', 'fragment');
                this.orchestrationState.metrics.security = await this.step17_SecurityVulnerabilityAssessment(finalCode);
                
                // STEP 18: Documentation & Explanation Generation
                await this.addLog('echo', 'üìù STEP 18: Generating Documentation...', 'consensus');
                finalCode = await this.step18_DocumentationExplanationGeneration(finalCode);
                
                // STEP 19: User Experience Integration
                await this.addLog('relay', '‚ú® STEP 19: Integrating User Experience...', 'event');
                this.orchestrationState.metrics.ux = await this.step19_UserExperienceIntegration(finalCode);
                
                // STEP 20: Final Orchestration Archive
                await this.addLog('nexus', 'üì¶ STEP 20: Archiving Orchestration Session...', 'genesis');
                await this.step20_FinalArchiveKnowledgeBase(finalCode);

                this.present20StepResults(finalCode, finalAnswer, allFragments);
                quantumNotify('20-Step Protocol Completed Successfully!', 'success');

            } catch (error) {
                console.error("20-Step Protocol error:", error);
                this.handleOrchestrationError(error);
                quantumNotify('Protocol Error: ' + error.message, 'error');
            } finally {
                this.finalizeOrchestration();
            }
        }

        // [All the step implementation methods remain exactly the same as before]
        // STEP 1-20 implementation methods...
        async step1_GenesisHashGeneration(promptText) {
            const genesisHash = await this.simulateSHA256('GENESIS_ROOT' + Date.now().toString() + promptText + Math.random().toString(36));
            this.fileSystem.genesisHash = genesisHash;
            this.fileSystem.genesisCounter = 0;
            await this.addLog('nexus', `‚úÖ Genesis Hash: ${genesisHash.substring(0, 20)}...`, 'genesis');
            return genesisHash;
        }

        async step2_AgentOriginHashCreation(genesisHash) {
            const agentCount = this.agentCount;
            this.orchestrationState.activeAgents.clear();
            const agentIds = ['nexus', 'cognito', 'relay', 'sentinel', 'echo'].slice(0, agentCount);

            for (let i = 0; i < agentIds.length; i++) {
                const agentId = agentIds[i];
                const originHash = await this.simulateSHA256(genesisHash + agentId + i.toString() + Math.random().toString());
                this.fileSystem.origins[agentId] = { hash: originHash, prevHash: genesisHash, count: i, role: agentId, entropy: this.calculateEntropy(originHash) };
                this.orchestrationState.agentData[agentId].origin = originHash;
                this.orchestrationState.activeAgents.add(agentId);
                await this.addLog('cognito', `   ${agentId} ‚Üí Origin: ${originHash.substring(0, 10)}...`, 'origin');
            }
            await this.addLog('cognito', `‚úÖ ${agentCount} agent origins created`, 'origin');
        }

        async step3_PromptDeconstruction(promptText, genesisHash) {
            const timestampIndexer = Date.now().toString(36);
            await this.addLog('relay', `‚è±Ô∏è Timestamp Indexer: ${timestampIndexer}`, 'event');
            const event = { prompt: promptText, timestamp: timestampIndexer, genesis: genesisHash, delegator: 'relay' };
            this.fileSystem.eventLog.push(event);
            return timestampIndexer;
        }

        async step4_ParallelFractalReasoning(promptText, editorContext, indexer) {
            const allFragments = [];
            this.fileSystem.tokenPool = [];

            for (let round = 0; round < this.maxRounds; round++) {
                this.orchestrationState.currentRound = round;
                await this.addLog('relay', `\n‚ö° ROUND ${round + 1}/${this.maxRounds}`, 'event');

                const agents = Array.from(this.orchestrationState.activeAgents);
                const roundPromises = agents.map(agentId =>
                    this.reasonAgent(agentId, round, promptText, editorContext, indexer)
                );

                const roundFragments = await Promise.all(roundPromises);
                allFragments.push(...roundFragments);
                await this.addLog('sentinel', `‚úÖ Round ${round + 1}: ${roundFragments.length} fragments`, 'fragment');
                await new Promise(r => setTimeout(r, 100));
            }
            return allFragments;
        }

        async reasonAgent(agentId, round, promptText, context, indexer) {
            const agent = this.fileSystem.origins[agentId];
            const originHash = this.orchestrationState.agentData[agentId].origin;
            const reasoningOutput = await this.performSimulatedReasoning(agentId, round, promptText, context, originHash);
            const tokenChunk = reasoningOutput.substring(0, 50) + '...';
            const fragmentHash = await this.simulateSHA256(reasoningOutput + indexer + originHash);
            const fragmentEntropy = this.calculateEntropy(fragmentHash) * (1 + round * 0.1);

            const fragment = {
                agentId, role: agent.role, origin: originHash, prevOrigin: originHash,
                fragmentHash, entropy: fragmentEntropy, round, candidate: reasoningOutput,
                tokenChunk: tokenChunk, collaborative: false
            };

            this.fileSystem.tokenPool.push({ hash: fragmentHash, content: reasoningOutput, entropy: fragmentEntropy, origin: originHash });
            await this.addLog('sentinel', `   [${agentId}] Entropy: ${fragmentEntropy.toFixed(2)}`, 'fragment');
            return fragment;
        }

        async step5_GenesisCounterMemoryStaging(fragments) {
            this.fileSystem.genesisCounter++;
            const counterHash = await this.simulateSHA256(this.fileSystem.genesisHash + this.fileSystem.genesisCounter.toString());
            await this.addLog('nexus', `üîÑ Genesis Counter: ${this.fileSystem.genesisCounter}`, 'genesis');

            fragments.forEach(fragment => {
                const newOrigin = this.simulateSHA256(fragment.prevOrigin + counterHash);
                fragment.origin = newOrigin;
                fragment.rehashChain = `${fragment.prevOrigin.substring(0, 8)} ‚Üí ${newOrigin.substring(0, 8)}`;
                if (this.fileSystem.origins[fragment.agentId]) {
                    this.fileSystem.origins[fragment.agentId].hash = newOrigin;
                }
            });
            await this.addLog('sentinel', `‚úÖ All fragments rehashed`, 'fragment');
        }

        step6_EntropyBasedReasoningAcceleration(fragments) {
            fragments.sort((a, b) => b.entropy - a.entropy);
            const highEntropyThreshold = fragments[0].entropy * 0.9;
            const highEntropyFragments = fragments.filter(f => f.entropy >= highEntropyThreshold);
            this.addLog('cognito', `‚¨ÜÔ∏è Prioritized ${highEntropyFragments.length} high-entropy fragments`, 'origin');
            this.orchestrationState.metrics.highEntropyFragments = highEntropyFragments.length;
            return fragments;
        }

        step7_MultiAgentCollaborationEnforcement(fragments) {
            const topFragments = fragments.slice(0, 5);
            let collaborationCount = 0;

            for (let i = 0; i < topFragments.length; i++) {
                for (let j = i + 1; j < topFragments.length; j++) {
                    const fragA = topFragments[i];
                    const fragB = topFragments[j];
                    if (fragA.entropy + fragB.entropy > 25 && Math.random() < this.orchestrationState.collaborationIntensity) {
                        const boostedEntropy = (fragA.entropy + fragB.entropy) * 0.55 * Math.random() * 0.2;
                        fragA.entropy = Math.min(30, fragA.entropy + boostedEntropy);
                        fragA.collaborative = true;
                        collaborationCount++;
                        const pairKey = [fragA.agentId, fragB.agentId].sort().join('-');
                        this.fileSystem.collaborationGraph.set(pairKey, (this.fileSystem.collaborationGraph.get(pairKey) || 0) + 1);
                    }
                }
            }
            this.addLog('cognito', `ü§ù Enforced ${collaborationCount} collaborations`, 'origin');
            this.orchestrationState.metrics.collaborationCount = collaborationCount;
            return fragments;
        }

        async step8_RealstreamThinkingInjection(fragments, indexer) {
            const realstreamData = JSON.stringify(fragments.map(f => ({ agent: f.agentId, rehash: f.origin, chunk: f.tokenChunk, entropy: f.entropy })));
            localStorage.setItem(`realstream_${indexer}`, realstreamData);
            await this.addLog('relay', `üíæ Stored ${fragments.length} fragments`, 'event');
            const tokenChunks = fragments.slice(0, 3).map(f => `// [${f.agentId}] E:${f.entropy.toFixed(2)}`).join('\n');
            const injection = `\n// --- REALSTREAM THINKING (Step 8) ---\n${tokenChunks}\n// ----------------------------------\n`;
            quantumEditor.insertCodeAtCursor(injection);
        }

        async step9_FinalAnswerSourcingValidation(fragments) {
            const bestFragment = fragments.reduce((max, frag) => (frag.entropy > max.entropy ? frag : max), fragments[0]);
            await this.addLog('sentinel', `üí° Best fragment: ${bestFragment.agentId} (E:${bestFragment.entropy.toFixed(3)})`, 'fragment');
            const finalCandidate = `// üéâ 20-STEP PROTOCOL: Final Candidate\n// Agent: ${bestFragment.agentId} | Entropy: ${bestFragment.entropy.toFixed(3)}\n// Genesis Chain: ${bestFragment.rehashChain || 'Validated'}\n${bestFragment.candidate}`;
            const nexusConfirmation = await this.validateNexusConfirmation(bestFragment.origin);
            await this.addLog('nexus', `‚úÖ ${nexusConfirmation}`, 'genesis');
            return { bestCandidate: finalCandidate, bestFragment, allFragments: fragments, score: bestFragment.entropy, nexusConfirmation };
        }

        async step10_CyclicTokenIntegration(finalCandidate) {
            const tokenPool = this.fileSystem.tokenPool.sort((a, b) => b.entropy - a.entropy);
            const activeAgentIds = Array.from(this.orchestrationState.activeAgents);
            let finalScript = finalCandidate;

            for (let i = 0; i < tokenPool.length; i++) {
                const chunk = tokenPool[i];
                const agentIndex = i % activeAgentIds.length;
                const agentId = activeAgentIds[agentIndex];
                const expectedHash = this.simulateSHA256(chunk.content);
                const isValid = chunk.hash.startsWith(expectedHash.substring(0, 5));
                if (isValid) {
                    finalScript += `\n// [Cyclic/${agentId}] Token ${i+1} (E:${chunk.entropy.toFixed(2)})`;
                }
            }

            quantumEditor.setContent(finalScript, quantumEditor.currentFileType);
            await this.addLog('echo', `üöÄ Cyclic token integration complete`, 'consensus');
            return finalScript;
        }

        async step11_GenesisChainVerification(fragments) {
            let integrityScore = 0;
            for (const fragment of fragments) {
                const isTraced = fragment.origin.includes(this.fileSystem.genesisHash.substring(0, 5));
                const hasRehashChain = fragment.rehashChain && fragment.rehashChain.length > 0;
                if (isTraced && hasRehashChain) integrityScore++;
            }
            const integrityRatio = integrityScore / fragments.length;
            const status = integrityRatio > 0.9 ? 'HIGH INTEGRITY' : 'LOW INTEGRITY';
            await this.addLog('nexus', `üîí ${status} (${(integrityRatio * 100).toFixed(1)}%)`, 'genesis');
            this.orchestrationState.metrics.integrity = integrityRatio;
            return integrityRatio;
        }

        async step12_MultiDimensionalEntropyAnalysis(fragments) {
            const entropies = fragments.map(f => f.entropy);
            const meanEntropy = entropies.reduce((a, b) => a + b, 0) / entropies.length;
            const variance = entropies.reduce((sum, num) => sum + Math.pow(num - meanEntropy, 2), 0) / entropies.length;
            const stdDev = Math.sqrt(variance);
            const optimalBalance = meanEntropy >= 15 && meanEntropy <= 25 && stdDev < 3;
            const status = optimalBalance ? 'OPTIMAL ENTROPY' : 'ENTROPY IMBALANCE';
            await this.addLog('sentinel', `üìà ${status} (Mean: ${meanEntropy.toFixed(2)})`, 'fragment');
            return { mean: meanEntropy, stdDev: stdDev, balance: optimalBalance };
        }

        async step13_CollaborativeConsensusScoring(fragments) {
            const consensusScore = this.orchestrationState.metrics.integrity * 0.4 + (1 - this.orchestrationState.metrics.entropyAnalysis.stdDev / 5) * 0.3 + this.orchestrationState.metrics.collaborationCount * 0.3 / (fragments.length * fragments.length / 2);
            const thresholdMet = consensusScore > this.orchestrationState.consensusThreshold;
            const status = thresholdMet ? 'CONSENSUS ACHIEVED' : 'CONSENSUS FAILED';
            await this.addLog('cognito', `ü§ù ${status} (Score: ${consensusScore.toFixed(3)})`, 'origin');
            return { score: consensusScore, thresholdMet: thresholdMet };
        }

        async step14_PromptAnswerAlignmentVerification(finalCode, promptText) {
            const requiredKeywords = promptText.toLowerCase().split(' ').filter(w => w.length > 3);
            let matchCount = 0;
            requiredKeywords.forEach(kw => { if (finalCode.toLowerCase().includes(kw)) matchCount++; });
            const alignmentScore = matchCount / requiredKeywords.length;
            const isAligned = alignmentScore > 0.7;
            const status = isAligned ? 'ALIGNED' : 'MISALIGNED';
            await this.addLog('relay', `üí¨ ${status} (${(alignmentScore * 100).toFixed(1)}%)`, 'event');
            return { score: alignmentScore, isAligned: isAligned };
        }

        async step15_CodeQualitySyntaxValidation(finalCode) {
            const hasSemicolon = finalCode.includes(';');
            const hasFunction = finalCode.includes('function');
            const hasBadEval = finalCode.includes('eval(');
            const qualityScore = (hasSemicolon + hasFunction - (hasBadEval * 2)) / 2;
            const status = qualityScore > 0.5 ? 'GOOD QUALITY' : 'QUALITY ISSUES';
            await this.addLog('echo', `üìê ${status} (Score: ${qualityScore.toFixed(1)})`, 'consensus');
            return { score: qualityScore, flags: hasBadEval ? ['UNSAFE_EVAL'] : [] };
        }

        async step16_PerformanceOptimizationLayer(finalCode) {
            const isOptimized = finalCode.length < 5000 && !finalCode.includes('for (let i = 0; i < 100000; i++)');
            const status = isOptimized ? 'OPTIMIZED' : 'NEEDS OPTIMIZATION';
            const optimizedCode = isOptimized ? finalCode : `// --- PERFORMANCE OPTIMIZED ---\n${finalCode}`;
            await this.addLog('sentinel', `‚ö° ${status}`, 'fragment');
            this.orchestrationState.metrics.isOptimized = isOptimized;
            return optimizedCode;
        }

        async step17_SecurityVulnerabilityAssessment(finalCode) {
            const hasXSS = finalCode.includes('innerHTML =');
            const hasSQLi = finalCode.includes('SELECT * FROM');
            const score = 1 - (hasXSS + hasSQLi);
            const status = score === 1 ? 'SECURE' : 'VULNERABLE';
            await this.addLog('sentinel', `üõ°Ô∏è ${status} (${(score * 100).toFixed(0)}%)`, 'fragment');
            this.orchestrationState.metrics.securityScore = score;
            return { score: score, vulnerabilities: hasXSS || hasSQLi };
        }

        async step18_DocumentationExplanationGeneration(finalCode) {
            const docBlock = `/**\n * @file 20-Step Quantum Protocol Generated Code\n * @version ${this.fileSystem.genesisCounter}.${this.orchestrationState.metrics.quality.score.toFixed(1)}\n * @description Generated via 20-Step Fractal Quantum Protocol\n * @consensus ${this.orchestrationState.metrics.consensus.score.toFixed(2)}\n */\n`;
            const documentedCode = docBlock + finalCode;
            await this.addLog('echo', `üìù Documentation generated`, 'consensus');
            return documentedCode;
        }

        async step19_UserExperienceIntegration(finalCode) {
            const hasErrorHandling = finalCode.includes('try {') && finalCode.includes('catch (');
            const isUsable = this.orchestrationState.metrics.alignment.isAligned && hasErrorHandling;
            const status = isUsable ? 'USABLE' : 'UX ISSUES';
            await this.addLog('relay', `‚ú® ${status}`, 'event');
            this.orchestrationState.metrics.hasErrorHandling = hasErrorHandling;
            return isUsable;
        }

        async step20_FinalArchiveKnowledgeBase(finalCode) {
            const sessionData = {
                timestamp: Date.now(),
                genesis: this.fileSystem.genesisHash,
                finalCode: finalCode,
                metrics: this.orchestrationState.metrics,
                fragments: this.fileSystem.fragments.length,
                prompt: this.orchestrationState.prompt
            };
            localStorage.setItem(`quantum_session_${Date.now()}`, JSON.stringify(sessionData));
            await this.addLog('nexus', `üì¶ Session archived | 20-STEP PROTOCOL COMPLETE`, 'genesis');
        }

        // Utility methods
        async performSimulatedReasoning(agentId, round, promptText, context, originHash) {
            return `// ${agentId} - Round ${round + 1}\n// Genesis: ${originHash.substring(0, 16)}...\n// Prompt: ${promptText.substring(0, 50)}${promptText.length > 50 ? '...' : ''}\nfunction quantum_${agentId}_round_${round}() {\n    const genesisRoot = '${this.fileSystem.genesisHash.substring(0, 8)}';\n    // Enhanced reasoning with fractal patterns\n    if (context.includes('welcome')) {\n        return applyQuantumFractal(genesisRoot, '${agentId}');\n    } else {\n        return execute20StepLogic(context);\n    }\n}`;
        }

        async validateNexusConfirmation(originHash) {
            if (this.fileSystem.genesisHash && originHash.includes(this.fileSystem.genesisHash.substring(0, 5))) {
                return 'Genesis trace validated';
            }
            return 'Genesis trace inconclusive';
        }

        simulateSHA256(input) {
            let hash = 0;
            for (let i = 0; i < input.length; i++) {
                const char = input.charCodeAt(i);
                hash = ((hash << 7) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36) + Math.random().toString(36).substring(2, 12);
        }

        calculateEntropy(hash) {
            const charCounts = {};
            for (const char of hash) {
                charCounts[char] = (charCounts[char] || 0) + 1;
            }
            let entropy = 0;
            const length = hash.length;
            for (const char in charCounts) {
                const probability = charCounts[char] / length;
                entropy -= probability * Math.log2(probability);
            }
            return entropy * 1.5;
        }

        // UI Management
        async present20StepResults(finalCode, finalAnswer, allFragments) {
            this.consensusPanel.style.display = 'block';
            const bestFragment = finalAnswer.bestFragment;
            this.consensusScore.textContent = `Score: ${bestFragment.entropy.toFixed(2)}`;

            const highlighter = new QuantumHighlighter();
            const highlightedCode = highlighter.highlight(finalCode, quantumEditor.currentFileType);

            const metrics = this.orchestrationState.metrics;
            const advancedMetrics = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; font-size: 11px;">
                    <div style="background: rgba(74, 201, 74, 0.1); padding: 8px; border-radius: 4px;">
                        <strong>Genesis Integrity</strong><br>${(metrics.integrity * 100).toFixed(1)}%
                    </div>
                    <div style="background: rgba(187, 134, 252, 0.1); padding: 8px; border-radius: 4px;">
                        <strong>Consensus Score</strong><br>${metrics.consensus.score.toFixed(3)}
                    </div>
                    <div style="background: rgba(3, 218, 198, 0.1); padding: 8px; border-radius: 4px;">
                        <strong>Quality/Security</strong><br>${metrics.quality.score.toFixed(1)} / ${metrics.securityScore.toFixed(2)}
                    </div>
                    <div style="background: rgba(255, 213, 79, 0.1); padding: 8px; border-radius: 4px;">
                        <strong>Alignment/UX</strong><br>${metrics.alignment.score.toFixed(2)} / ${metrics.ux ? 'OK' : 'FAIL'}
                    </div>
                </div>
            `;

            const quantumButtons = `
                <div class="action-buttons">
                    <button class="small success" onclick="quantumCopy20StepResult()">Copy 20-Step Result</button>
                    <button class="small info" onclick="quantumApply20StepResult()">Apply Result</button>
                    <button class="small" onclick="quantumRerun20StepProtocol()" style="background: var(--agent-nexus);">Rerun Protocol</button>
                </div>
            `;

            this.agents.echo.innerHTML = `
                <div style="border-left: 3px solid var(--agent-nexus); padding-left: 10px; margin-bottom: 15px;">
                    <strong>üéâ 20-STEP QUANTUM PROTOCOL COMPLETE</strong><br>
                    <small>Final Agent: ${bestFragment.agentId} | Entropy: ${bestFragment.entropy.toFixed(3)}</small>
                </div>
                ${advancedMetrics}
                <div style="margin-bottom: 10px;">
                    <strong>Final Generated Code:</strong>
                </div>
                <pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; overflow: auto; max-height: 300px; border: 1px solid var(--agent-cognito);">${highlightedCode}</pre>
                ${quantumButtons}
            `;

            window.quantum20StepCode = finalCode;
        }

        resetOrchestrationUI() {
            Object.values(this.agents).forEach(agent => {
                agent.innerHTML = 'Initializing 20-step quantum protocol...';
            });
            Object.values(this.agentCards).forEach(card => {
                card.classList.remove('active');
            });
            Object.values(this.logElements).forEach(log => {
                log.innerHTML = '';
            });
            this.agents.nexus.innerHTML = '<div class="quantum-spinner"></div>Starting 20-step quantum protocol...';
            this.agentCards.nexus.classList.add('active');
            this.fileSystem.fragments = [];
            this.fileSystem.tokenPool = [];
            this.fileSystem.collaborationGraph.clear();
        }

        finalizeOrchestration() {
            this.agents.nexus.innerHTML = '20-step protocol complete';
            this.agents.cognito.innerHTML = 'Origin analysis complete';
            this.agents.relay.innerHTML = 'Delegation complete';
            this.agents.sentinel.innerHTML = 'Security validation complete';
            this.agents.echo.innerHTML = 'Code synthesis complete';

            Object.values(this.agentCards).forEach(card => {
                card.classList.remove('active');
            });

            this.isGenerating = false;
            this.orchestrationState.currentRound = 0;
        }

        async addLog(agent, message, type = 'info') {
            const logEl = this.logElements[agent];
            if (!logEl) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;

            logEl.appendChild(logEntry);
            logEl.scrollTop = logEl.scrollHeight;

            this.agentCards[agent].classList.add('active');
            setTimeout(() => {
                this.agentCards[agent].classList.remove('active');
            }, 800);
        }

        handleOrchestrationError(error) {
            this.agents.echo.innerHTML = `<span style="color: #ff4444">20-Step Protocol Error: ${error.message}</span>`;
            console.error("20-Step Protocol Error:", error);
        }

        // Quick actions
        async quantumOptimize() { this.run20StepProtocol(); }
        async quantumDocument() { this.run20StepProtocol(); }
        async quantumRefactor() { this.run20StepProtocol(); }
    }

    /* =========================================================================
       QuantumHighlighter Class
       ========================================================================== */

    class QuantumHighlighter {
        constructor() {
            this.languages = {
                js: {
                    rules: [
                        {t:'comment',r:/^(\/\/[^\n]*|\/\*[\s\S]*?\*\/)/},
                        {t:'string',r:/^`(?:\\[\s\S]|[^`])*`|^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/},
                        {t:'number',r:/^\b(?:0x[a-fA-F0-9]+|[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)\b/},
                        {t:'keyword',r:/^\b(?:if|else|for|while|function|return|const|let|var|class|new|in|of|switch|case|break|continue|try|catch|throw|async|await|export|import|from|default)\b/},
                        {t:'function',r:/^\b[a-zA-Z_$][\w$]*(?=\s*\()/},
                        {t:'bracket',r:/^[\[\]\{\}\(\)]/},
                        {t:'op',r:/^==|===|!=|!==|<=|>=|=>|->|[-+*/%=<>!&|^~?:.,;]/},
                        {t:'id',r:/^\b[a-zA-Z_$][\w$]*\b/},
                        {t:'ws',r:/^\s+/}
                    ]
                },
                html: {
                    rules: [
                        {t:'comment',r:/^&lt;!--[\s\S]*?--&gt;/},
                        {t:'tag',r:/^&lt;\/?[^\s>\/]+/},
                        {t:'string',r:/^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/},
                        {t:'bracket',r:/^[\[\]\{\}\(\)]/},
                        {t:'op',r:/^==|===|!=|!==|<=|>=|=>|->|[-+*/%=<>!&|^~?:.,;]/},
                        {t:'ws',r:/^\s+/},
                        {t:'text',r:/^[^<]+/}
                    ]
                },
                css: {
                    rules: [
                        {t:'comment',r:/^(\/\/[^\n]*|\/\*[\s\S]*?\*\/)/},
                        {t:'string',r:/^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/},
                        {t:'number',r:/^\b(?:0x[a-fA-F0-9]+|[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)\b/},
                        {t:'keyword',r:/^\b(?:@import|@media|@keyframes|@font-face|!important|initial|inherit|unset)\b/},
                        {t:'property',r:/^[a-zA-Z-]+(?=\s*:)/},
                        {t:'bracket',r:/^[\[\]\{\}\(\)]/},
                        {t:'op',r:/^[:;,#.]/},
                        {t:'ws',r:/^\s+/}
                    ]
                }
            };
        }

        static escape(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        tokenize(text, language = 'js') {
            const rules = this.languages[language]?.rules || this.languages.js.rules;
            const tokens = [];
            let position = 0;

            while (position < text.length) {
                let matched = false;
                for (const rule of rules) {
                    rule.r.lastIndex = position;
                    const match = rule.r.exec(text);
                    if (match && match.index === position) {
                        tokens.push({ type: rule.t, value: match[0], length: match[0].length });
                        position += match[0].length;
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    tokens.push({ type: 'unknown', value: text[position], length: 1 });
                    position++;
                }
            }
            return tokens;
        }

        highlight(text, language = 'js') {
            const tokens = this.tokenize(text, language);
            return tokens.map(token =>
                `<span class="sh-token sh-${token.type}">${QuantumHighlighter.escape(token.value)}</span>`
            ).join('');
        }

        highlightElement(element, language = 'js') {
            const text = element.textContent || '';
            const html = this.highlight(text, language);
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0).cloneRange() : null;
            element.innerHTML = html;
            if (range) {
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
    }

    /* =========================================================================
       QuantumEditor Class
       ========================================================================== */

    class QuantumEditor {
        constructor() {
            this.editor = document.getElementById('editor');
            this.lineNumbers = document.getElementById('line-numbers');
            this.statusEditor = document.getElementById('editor-meta');
            this.statusFile = document.getElementById('file-meta');
            this.highlighter = new QuantumHighlighter();
            this.quantumThinking = document.getElementById('quantum-thinking');

            this.currentFileName = null;
            this.currentFileType = 'html';
            this.historyStack = [];
            this.redoStack = [];
            this.isComposing = false;
            this.quantumMode = true;
            this.hyperthreading = true;
            this.multiAgentMode = true;

            this.init();
        }

        init() {
            this.bindEvents();
            this.render(this.editor.textContent);
            this.pushHistory();
            this.initQuantumVisuals();
            console.log('Quantum Editor initialized');
        }

        initQuantumVisuals() {
            const threadsContainer = document.getElementById('quantum-threads');
            for (let i = 0; i < 5; i++) {
                const thread = document.createElement('div');
                thread.className = 'quantum-thread';
                thread.style.left = `${20 + i * 15}%`;
                thread.style.animationDelay = `${i * 0.3}s`;
                threadsContainer.appendChild(thread);
            }
        }

        createFractalNodes() {
            if (!this.quantumMode) return;
            this.quantumThinking.innerHTML = '';
            const nodeCount = this.hyperthreading ? 12 : 6;
            for (let i = 0; i < nodeCount; i++) {
                const node = document.createElement('div');
                node.className = 'fractal-node';
                node.style.left = `${Math.random() * 100}%`;
                node.style.top = `${Math.random() * 100}%`;
                node.style.animationDelay = `${Math.random() * 2}s`;
                node.style.background = i % 2 === 0 ? 'var(--agent-nexus)' : 'var(--agent-cognito)';
                this.quantumThinking.appendChild(node);
            }
        }

        bindEvents() {
            // Editor events
            this.editor.addEventListener('input', this.handleInput.bind(this));
            this.editor.addEventListener('compositionstart', () => this.isComposing = true);
            this.editor.addEventListener('compositionend', () => {
                this.isComposing = false;
                this.handleInput();
            });
            this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
            this.editor.addEventListener('click', this.updateStatus.bind(this));
            this.editor.addEventListener('keyup', this.updateStatus.bind(this));
            this.editor.addEventListener('scroll', this.syncScroll.bind(this));

            // Settings bindings
            document.getElementById('quantum-mode').addEventListener('change', (e) => {
                this.quantumMode = e.target.checked;
                if (this.quantumMode) {
                    this.createFractalNodes();
                } else {
                    this.quantumThinking.innerHTML = '';
                }
            });

            document.getElementById('hyperthreading').addEventListener('change', (e) => {
                this.hyperthreading = e.target.checked;
                if (this.quantumMode) {
                    this.createFractalNodes();
                }
            });

            document.getElementById('multi-agent-mode').addEventListener('change', (e) => {
                this.multiAgentMode = e.target.checked;
            });

            console.log('Editor events bound successfully');
        }

        handleInput() {
            if (this.isComposing) return;
            this.pushHistory();
            this.highlightContent();
            this.updateLineNumbers();
            this.updateStatus();
            if (this.quantumMode) {
                this.createFractalNodes();
            }
        }

        handleKeydown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                this.insertText('    ');
            }
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    event.preventDefault();
                    this.undo();
                } else if (event.key === 'z' && event.shiftKey) {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 'y') {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 's') {
                    event.preventDefault();
                    quantumSaveFile();
                }
            }
        }

        insertText(text) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            range.deleteContents();
            range.insertNode(document.createTextNode(text));
            range.setStart(range.endContainer, range.endOffset);
            range.setEnd(range.endContainer, range.endOffset);
            selection.removeAllRanges();
            selection.addRange(range);
            this.handleInput();
        }

        highlightContent() {
            this.highlighter.highlightElement(this.editor, this.currentFileType);
        }

        updateLineNumbers() {
            const text = this.editor.textContent || '';
            const lines = text.split('\n');
            const lineCount = lines.length;
            let lineNumbersHTML = '';
            for (let i = 1; i <= lineCount; i++) {
                lineNumbersHTML += i + '<br>';
            }
            this.lineNumbers.innerHTML = lineNumbersHTML;
            this.lineNumbers.style.height = this.editor.scrollHeight + 'px';
        }

        syncScroll() {
            this.lineNumbers.scrollTop = this.editor.scrollTop;
        }

        updateStatus() {
            const selection = window.getSelection();
            const text = this.editor.textContent || '';
            const lines = text.split('\n');
            let lineNum = 1;
            let colNum = 0;

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(this.editor);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                const preCaretText = preCaretRange.toString();
                const preCaretLines = preCaretText.split('\n');
                lineNum = preCaretLines.length;
                colNum = preCaretLines[preCaretLines.length - 1].length;
            }

            const quantumStatus = this.quantumMode ? ` | Quantum: ${this.hyperthreading ? 'Hyperthreaded' : 'Standard'}` : ' | Classical Mode';
            const agentStatus = this.multiAgentMode ? ' | Multi-Agent' : ' | Single-Agent';
            this.statusEditor.textContent = `Cursor: ${lineNum}:${colNum} | Lines: ${lines.length} | Chars: ${text.length} | History: ${this.historyStack.length}${quantumStatus}${agentStatus}`;
        }

        pushHistory() {
            const content = this.editor.textContent;
            if (this.historyStack.length && this.historyStack[this.historyStack.length - 1] === content) return;
            this.historyStack.push(content);
            this.redoStack = [];
        }

        undo() {
            if (this.historyStack.length > 1) {
                this.redoStack.push(this.historyStack.pop());
                this.render(this.historyStack[this.historyStack.length - 1]);
            }
        }

        redo() {
            if (this.redoStack.length) {
                const content = this.redoStack.pop();
                this.historyStack.push(content);
                this.render(content);
            }
        }

        render(content) {
            this.editor.textContent = content;
            this.highlightContent();
            this.updateLineNumbers();
            this.updateStatus();
            if (this.quantumMode) {
                this.createFractalNodes();
            }
        }

        setContent(content, fileType = 'html') {
            this.currentFileType = fileType;
            this.render(content);
            this.historyStack = [content];
            this.redoStack = [];
        }

        getContent() {
            return this.editor.textContent;
        }

        insertCodeAtCursor(code) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            range.deleteContents();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = code;
            const fragment = document.createDocumentFragment();
            while (tempDiv.firstChild) {
                fragment.appendChild(tempDiv.firstChild);
            }
            range.insertNode(fragment);
            range.setStartAfter(fragment.lastChild);
            range.setEndAfter(fragment.lastChild);
            selection.removeAllRanges();
            selection.addRange(range);
            this.handleInput();
        }

        replaceSelectionWithCode(code) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            range.deleteContents();
            const textNode = document.createTextNode(code);
            range.insertNode(textNode);
            range.setStartAfter(textNode);
            range.setEndAfter(textNode);
            selection.removeAllRanges();
            selection.addRange(range);
            this.handleInput();
        }

        // Code formatting and beautification
        beautifyCode() {
            try {
                const content = this.getContent();
                let formatted = content;
                // Basic formatting rules
                formatted = formatted.replace(/\s+/g, ' ');
                formatted = formatted.replace(/\s*{\s*/g, ' { ');
                formatted = formatted.replace(/\s*}\s*/g, ' } ');
                formatted = formatted.replace(/\s*\(\s*/g, ' ( ');
                formatted = formatted.replace(/\s*\)\s*/g, ' ) ');
                formatted = formatted.replace(/;\s+/g, ';\n');
                formatted = formatted.replace(/\n\s*\n/g, '\n');
                this.setContent(formatted);
                quantumNotify('Code beautified', 'success');
            } catch (error) {
                quantumNotify('Beautification failed', 'error');
            }
        }
    }

    /* =========================================================================
       Global Functions and Initialization
       ========================================================================== */

    // Global 20-step protocol functions
    function quantumCopy20StepResult() {
        if (window.quantum20StepCode) {
            navigator.clipboard.writeText(window.quantum20StepCode).then(() => {
                quantumNotify('20-step protocol result copied to clipboard!', 'success');
            });
        }
    }

    function quantumApply20StepResult() {
        if (window.quantum20StepCode) {
            quantumEditor.setContent(window.quantum20StepCode, quantumEditor.currentFileType);
            quantumNotify('20-step protocol result applied!', 'success');
        }
    }

    function quantumRerun20StepProtocol() {
        enhancedOrchestrator.run20StepProtocol();
    }

    function quantumNotify(message, type = 'info') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? 'var(--accent)' :
                        type === 'warn' ? 'var(--warn-bg)' :
                        type === 'error' ? 'var(--err)' : 'var(--info)'};
            color: ${type === 'warn' ? '#3a3c31' : 'white'};
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 1000;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(notification);
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 3000);
    }

    // Global variables
    let quantumEditor;
    let enhancedOrchestrator;

    // Initialize application
    document.addEventListener('DOMContentLoaded', () => {
        try {
            quantumEditor = new QuantumEditor();
            enhancedOrchestrator = new EnhancedQuantumOrchestrator();

            // Initialize all functionality
            initQuantumFileHandling();
            initQuantumAI();
            initQuantumPreview();
            initQuantumLeftPanel();
            initQuantumQuickActions();

            quantumNotify('20-Step Quantum Protocol Editor Ready', 'success');
            console.log('Application fully initialized');
        } catch (error) {
            console.error('Initialization failed:', error);
            quantumNotify('Initialization failed - check console', 'error');
        }
    });

    // File handling
    function initQuantumFileHandling() {
        document.getElementById('open-file').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', handleFileOpen);
        document.getElementById('save-file').addEventListener('click', quantumSaveFile);
        document.getElementById('save-as').addEventListener('click', quantumSaveAsFile);

        console.log('File handling initialized');
    }

    function handleFileOpen(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
            const fileName = file.name;
            const fileType = detectQuantumLanguage(fileName);
            quantumEditor.setContent(ev.target.result, fileType);
            document.getElementById('file-meta').textContent = fileName;
            quantumEditor.currentFileName = fileName;
        };
        reader.readAsText(file);
    }

    function detectQuantumLanguage(fileName) {
        const ext = fileName?.split('.').pop().toLowerCase();
        const languageMap = {
            'js': 'js', 'jsx': 'js', 'ts': 'js', 'tsx': 'js',
            'html': 'html', 'htm': 'html',
            'css': 'css',
            'json': 'js', 'txt': 'js'
        };
        return languageMap[ext] || 'html';
    }

    function quantumSaveFile() {
        if (!quantumEditor.currentFileName) {
            quantumSaveAsFile();
            return;
        }
        const blob = new Blob([quantumEditor.getContent()], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = quantumEditor.currentFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        quantumNotify('File saved successfully', 'success');
    }

    function quantumSaveAsFile() {
        const fileName = prompt('Enter file name:', quantumEditor.currentFileName || 'quantum_code.html');
        if (fileName) {
            quantumEditor.currentFileName = fileName;
            quantumEditor.currentFileType = detectQuantumLanguage(fileName);
            document.getElementById('file-meta').textContent = fileName;
            quantumSaveFile();
        }
    }

    // AI functionality
    function initQuantumAI() {
        document.getElementById('send-button').addEventListener('click', runQuantumAI);
        document.getElementById('run-local-ai').addEventListener('click', runQuantumAI);

        document.getElementById('prompt-input').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                runQuantumAI();
            }
        });

        document.getElementById('close-ai-panel').addEventListener('click', () => {
            document.getElementById('ai-response-panel').style.display = 'none';
        });

        console.log('AI functionality initialized');
    }

    function runQuantumAI() {
        const promptInput = document.getElementById('prompt-input');
        const prompt = promptInput.value.trim();
        if (!prompt) {
            quantumNotify('Please enter a prompt', 'warn');
            return;
        }

        if (quantumEditor.multiAgentMode) {
            enhancedOrchestrator.run20StepProtocol();
        } else {
            quantumNotify('20-step protocol requires multi-agent mode', 'warn');
        }
        promptInput.value = '';
    }

    // Preview functionality
    function initQuantumPreview() {
        document.getElementById('btn-render').addEventListener('click', renderQuantumHTML);
        document.getElementById('render-html').addEventListener('click', renderQuantumHTML);

        document.getElementById('close-preview').addEventListener('click', () => {
            document.getElementById('preview-panel').style.display = 'none';
            const previewContent = document.getElementById('preview-content');
            if (previewContent.src.startsWith('blob:')) {
                URL.revokeObjectURL(previewContent.src);
            }
        });

        console.log('Preview functionality initialized');
    }

    function renderQuantumHTML() {
        try {
            const blob = new Blob([quantumEditor.getContent()], { type: 'text/html' });
            const previewContent = document.getElementById('preview-content');
            previewContent.src = URL.createObjectURL(blob);
            document.getElementById('preview-panel').style.display = 'flex';
        } catch (e) {
            alert('Quantum rendering error: ' + e.message);
        }
    }

    // Left panel functionality
    function initQuantumLeftPanel() {
        document.getElementById('left-toggle').addEventListener('click', () => {
            const isOpen = document.getElementById('editor-stage').classList.toggle('left-panel-open');
            document.getElementById('left-toggle').textContent = isOpen ? '‚úï' : '‚ò∞';
        });

        document.getElementById('btn-undo').addEventListener('click', () => quantumEditor.undo());
        document.getElementById('btn-redo').addEventListener('click', () => quantumEditor.redo());
        document.getElementById('btn-beautify').addEventListener('click', () => quantumEditor.beautifyCode());

        console.log('Left panel functionality initialized');
    }

    // Quick actions
    function initQuantumQuickActions() {
        document.getElementById('btn-optimize').addEventListener('click', () => enhancedOrchestrator.quantumOptimize());
        document.getElementById('btn-document').addEventListener('click', () => enhancedOrchestrator.quantumDocument());
        document.getElementById('btn-refactor').addEventListener('click', () => enhancedOrchestrator.quantumRefactor());

        console.log('Quick actions initialized');
    }

    // Global error handler
    window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        quantumNotify('Unexpected error occurred', 'error');
    });
</script>
<script type="module" src="./assets/index-pUJ_og10.js"></script>
</body>
</html>
