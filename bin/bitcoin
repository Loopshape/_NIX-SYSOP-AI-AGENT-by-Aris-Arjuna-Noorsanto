#!/usr/bin/env bash
# ai.sh - AI DevOps Platform v14.5 - The Migration Edition
# Fixed schema errors with a robust, non-destructive database migration system.

set -euo pipefail
IFS=$'\n\t'

# --- RUNTIME MODE DETECTION ---
if [[ "${1:-}" == "serve" ]]; then
    # Web Server Mode - Embedded Node.js
    exec node --input-type=module - "$0" "$@" <<'NODE_EOF'
import http from 'http';
import { exec } from 'child_process';

const PORT = process.env.AI_PORT || 8080;
const AI_SCRIPT_PATH = process.argv;

const HTML_UI = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><title>AI DevOps Platform v14.5</title>
    <style>:root{--bg:#0f0f23;--text:#00ff00;--accent:#ff6ec7;--secondary:#6a67ce;}body{font-family:'Courier New',monospace;background:var(--bg);color:var(--text);}
    .terminal{background:#000;border:2px solid var(--accent);border-radius:10px;padding:20px;margin:20px;height:70vh;overflow-y:auto;}
    .input-line{display:flex;margin-top:10px;border-top:1px solid var(--secondary);padding-top:10px;}
    .prompt{color:var(--accent);margin-right:10px;}input{flex:1;background:transparent;border:none;color:var(--text);font-family:inherit;font-size:inherit;outline:none;}
    .output{white-space:pre-wrap;}.success{color:#00ff88;}.error{color:#ff4444;}</style>
</head>
<body>
    <div style="text-align:center;padding:20px;border-bottom:2px solid var(--accent);"><h1>🤖 AI DevOps Platform v14.5</h1></div>
    <div class="terminal"><div id="output" class="output"><div>🚀 AI Agent ready.</div></div><div class="input-line"><span class="prompt">ai&gt;</span><input type="text" id="commandInput"></div></div>
    <script>
        const output=document.getElementById('output'),input=document.getElementById('commandInput');
        function addOutput(text,className=''){const d=document.createElement('div');d.className=className;d.textContent=text;output.appendChild(d);output.scrollTop=output.scrollHeight;}
        async function executeCommand(cmd){addOutput(\`ai> \${cmd}\`,'prompt');try{const r=await fetch('/api/command',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({command:cmd})}),d=await r.json();addOutput(d.output,d.success?'success':'error');}catch(e){addOutput(\`Error: \${e.message}\`,'error');}}
        input.addEventListener('keypress',e=>{if(e.key==='Enter'){const c=input.value.trim();if(c){executeCommand(c);input.value='';}}});input.focus();
    </script>
</body></html>`;

http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    if (req.method === 'OPTIONS') { res.writeHead(200); res.end(); return; }
    if (req.url === '/' && req.method === 'GET') { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(HTML_UI); return; }
    if (req.url === '/api/command' && req.method === 'POST') {
        let body = '';
        req.on('data', c => body += c.toString());
        req.on('end', () => {
            try {
                const { command } = JSON.parse(body);
                const sanitizedCmd = command.replace(/(["'$`\\])/g,'\\$1');
                exec(`"${AI_SCRIPT_PATH}" ${sanitizedCmd}`, { timeout: 600000 }, (err, stdout, stderr) => {
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    if (err) { res.end(JSON.stringify({ success: false, output: `Error: ${err.message}\n${stderr}` }));
                    } else { res.end(JSON.stringify({ success: true, output: stdout || 'Command executed.' })); }
                });
            } catch (e) { res.writeHead(400, { 'Content-Type': 'application/json' }); res.end(JSON.stringify({ success: false, output: 'Invalid request.' })); }
        });
        return;
    }
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));
}).listen(PORT, () => console.log(`🌐 AI Web UI: http://localhost:${PORT}`));
NODE_EOF
fi

# --- BASH AGENT CORE (v14.5) ---

# --- CONFIGURATION ---
AI_HOME="${AI_HOME:-$HOME/.ai_agent}"
PROJECTS_DIR="${PROJECTS_DIR:-$HOME/ai_projects}"
LOG_FILE="$AI_HOME/ai.log"
DEFAULT_MODEL="llama3.1:8b"
AGENT_MODEL="${AI_MODEL:-$DEFAULT_MODEL}"
REVIEWER_MODEL="${REVIEWER_MODEL:-$DEFAULT_MODEL}"
TESTER_MODEL="${TESTER_MODEL:-$DEFAULT_MODEL}"
OLLAMA_BIN="$(command -v ollama || echo 'ollama')"
MEMORY_DB="$AI_HOME/memory.db"
HASH_INDEX_DB="$AI_HOME/hash_index.db"
CONFIG_DB="$AI_HOME/config.db"
MAX_AGENT_LOOPS=5
DB_SCHEMA_VERSION=2 # The target schema version this script requires

# --- COLORS & ICONS ---
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'; NC='\033[0m'
ICON_SUCCESS="✅"; ICON_WARN="⚠️"; ICON_ERROR="❌"; ICON_INFO="ℹ️"

# --- LOGGING ---
log() { printf "${BLUE}${ICON_INFO} [%s] %s${NC}\n" "$(date '+%T')" "$*" >&2; }
log_success() { printf "${GREEN}${ICON_SUCCESS} [%s] %s${NC}\n" "$(date '+%T')" "$*" >&2; }
log_error() { printf "${RED}${ICON_ERROR} [%s] ERROR: %s${NC}\n" "$(date '+%T')" "$*" >&2; exit 1; }
log_phase() { echo -e "\n${PURPLE}🚀 %s${NC}" "$*" >&2; }

# --- DATABASE SYSTEM (WITH MIGRATION) ---
init_db() {
    # This function creates tables with the LATEST schema.
    sqlite3 "$MEMORY_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, prompt TEXT, project TEXT, status TEXT, hash TEXT UNIQUE);" 2>/dev/null || true
    sqlite3 "$HASH_INDEX_DB" "CREATE TABLE IF NOT EXISTS hashes (id INTEGER PRIMARY KEY, file_path TEXT UNIQUE, hash TEXT, timestamp DATETIME);" 2>/dev/null || true
    sqlite3 "$CONFIG_DB" "CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);" 2>/dev/null || true
}
sqlite_escape() { echo "$1" | sed "s/'/''/g"; }

# --- SCHEMA MIGRATION ---
check_and_migrate_db() {
    # Ensure config table exists to check version
    init_db
    local current_version; current_version=$(get_config "db_schema_version" || echo 1)
    
    if (( current_version < DB_SCHEMA_VERSION )); then
        log_warn "Outdated database schema detected (v$current_version). Attempting to upgrade to v$DB_SCHEMA_VERSION..."
        
        # Migration from v1 to v2: Add 'hash' column to memories table
        if (( current_version < 2 )); then
            log "Applying migration v2: Adding 'hash' column to memories table..."
            # Use PRAGMA to check if column exists before trying to add it
            if ! sqlite3 "$MEMORY_DB" "PRAGMA table_info(memories);" | grep -q "hash"; then
                sqlite3 "$MEMORY_DB" "ALTER TABLE memories ADD COLUMN hash TEXT UNIQUE;" 2>/dev/null || log_warn "Could not add 'hash' column. It might already exist."
            fi
        fi
        
        # ... future migrations would go here in 'if (( current_version < 3 ))' blocks ...
        
        set_config "db_schema_version" "$DB_SCHEMA_VERSION"
        log_success "Database schema upgraded to v$DB_SCHEMA_VERSION."
    else
        log "Database schema is up to date (v$current_version)."
    fi
}

# --- CONFIG MANAGEMENT ---
set_config() { sqlite3 "$CONFIG_DB" "INSERT OR REPLACE INTO config (key, value) VALUES ('$(sqlite_escape "$1")', '$(sqlite_escape "$2")');"; }
get_config() { sqlite3 "$CONFIG_DB" "SELECT value FROM config WHERE key = '$1';" 2>/dev/null; }
load_config() { AGENT_MODEL=$(get_config agent_model || echo "$DEFAULT_MODEL"); }

# --- MEMORY & HASHING CORE ---
add_to_memory() {
    local prompt="$1" project="$2" status="$3" hash="$4"
    sqlite3 "$MEMORY_DB" "INSERT OR REPLACE INTO memories (prompt, project, status, hash) VALUES ('$(sqlite_escape "$prompt")', '$(sqlite_escape "$project")', '$status', '$hash');"
}
search_memory() {
    sqlite3 "$MEMORY_DB" "SELECT hash FROM memories WHERE prompt LIKE '%$(sqlite_escape "$1")%' AND status = 'SUCCESS' ORDER BY timestamp DESC LIMIT 1;"
}
index_file_hash() {
    if [[ ! -f "$1" ]]; then return; fi
    local hash; hash=$(sha256sum "$1" | awk '{print $1}')
    sqlite3 "$HASH_INDEX_DB" "INSERT OR REPLACE INTO hashes (file_path, hash, timestamp) VALUES ('$(sqlite_escape "$1")', '$hash', CURRENT_TIMESTAMP);"
    echo "$hash"
}
get_hashes_for_memory() {
    sqlite3 -header -column "$HASH_INDEX_DB" "SELECT file_path, hash FROM hashes WHERE file_path LIKE '%$1%' ORDER BY timestamp DESC;"
}

# --- AI & AGI ---
ensure_ollama() { if ! command -v "$OLLAMA_BIN" &>/dev/null; then log_error "Ollama not found."; fi; if ! curl -s http://localhost:11434/api/tags >/dev/null; then log "Starting Ollama..."; nohup "$OLLAMA_BIN" serve >/dev/null 2>&1 & sleep 3; fi; }
run_ai_model() { ensure_ollama; ollama run "$AGENT_MODEL" "$1"; }
confirm_action() { echo -e "\n${YELLOW}PROPOSED ACTION:${NC} ${CYAN}$1${NC}"; read -p "Approve? [y/N] " -n 1 -r c; echo; [[ "$c" =~ ^[Yy]$ ]]; }

run_agi_workflow() {
    local user_prompt="$*"
    local project_name; project_name=$(echo "$user_prompt" | tr ' ' '-' | tr -cd 'a-zA-Z0-9-' | cut -c1-32)
    local project_dir="$PROJECTS_DIR/$project_name"; mkdir -p "$project_dir"; cd "$project_dir"
    log_phase "🚀 AGI Workflow: $project_name"; log_success "Project directory: $project_dir"
    log "Searching memory..."; local past_task_hash; past_task_hash=$(search_memory "$user_prompt")
    local memory_context="This is a new task."
    if [[ -n "$past_task_hash" ]]; then log_success "Found relevant memory: $past_task_hash"; memory_context="CONTEXT FROM PAST TASK (hash: $past_task_hash):\n$(get_hashes_for_memory "$past_task_hash")"; fi
    local language; language=$(run_ai_model "Detect language from prompt. Output ONLY name. Prompt: $user_prompt")
    local main_file="main.${language/javascript/js}"; log "Language: $language | Main: $main_file"
    local code; code=$(run_ai_model "You are CODER. Write code for '$main_file'. Output ONLY code. $memory_context. Request: $user_prompt.")
    echo "$code" > "$main_file"; local final_hash; final_hash=$(index_file_hash "$main_file"); add_to_memory "$user_prompt" "$project_name" "SUCCESS" "$final_hash"
    log_phase "🏁 AGI Workflow Complete"; echo "Status: SUCCESS"; echo "Final Hash: $final_hash"
}

# --- HELP & MAIN DISPATCHER ---
show_help() {
    cat << EOF
${GREEN}AI DevOps Platform v14.5 - The Migration Edition${NC}
An AGI workflow with a persistent, self-migrating Memory & Hashing Core.
... (help text) ...
EOF
}

main() {
    mkdir -p "$AI_HOME"; init_db
    check_and_migrate_db
    load_config
    if [[ $# -eq 0 ]]; then show_help; return 0; fi
    
    case "$1" in
        --setup|-s)
            log "Installing dependencies..."
            if command -v apt-get &>/dev/null; then sudo apt-get update && sudo apt-get install -y sqlite3 git curl nodejs npm tree; fi
            log_success "Setup complete. Forcing database migration check..."
            check_and_migrate_db
            ;;
        memory)
            shift; local op="${1:-search}"; local query="${2:-}"
            case "$op" in
                search) search_memory "$query";;
                clear) if confirm_action "Clear ALL memory?"; then sqlite3 "$MEMORY_DB" "DELETE FROM memories;"; fi;;
                *) log_error "Usage: ai memory [search|clear]";;
            esac
            ;;
        hash)
            shift; local op="${1:-view}"
            case "$op" in
                view) sqlite3 -header -column "$HASH_INDEX_DB" "SELECT * FROM hashes ORDER BY timestamp DESC;";;
                clear) if confirm_action "Clear ALL hashes?"; then sqlite3 "$HASH_INDEX_DB" "DELETE FROM hashes;"; fi;;
                *) log_error "Usage: ai hash [view|clear]";;
            esac
            ;;
        --help|-h) show_help ;;
        *) run_agi_workflow "$@" ;;
    esac
}

# --- ENTRY POINT ---
main "$@"
