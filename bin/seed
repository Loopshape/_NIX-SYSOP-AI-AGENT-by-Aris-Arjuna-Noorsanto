#!/usr/bin/env bash
# ai.sh - AI DevOps Platform v8.2 - Asynchronous Mind Edition
# Enhanced with comprehensive verbose thinking display

set -euo pipefail
IFS=$'\n\t'

# --- CONFIGURATION ---
AI_HOME="${AI_HOME:-$HOME/.ai_agent}"
PROJECTS_DIR="${PROJECTS_DIR:-$HOME/ai_projects}"

# Worker Models
DEFAULT_MESSENGER_MODEL="gemma3:1b"
DEFAULT_COMBINATOR_MODEL="deepseek-r1:1.5b"
DEFAULT_TRADER_MODEL="2244-1"

MESSENGER_MODEL=""
COMBINATOR_MODEL=""
TRADER_MODEL=""

OLLAMA_BIN="$(command -v ollama || true)"
MEMORY_DB="$AI_HOME/memory.db"
CONFIG_DB="$AI_HOME/config.db"

API_PORT="${API_PORT:-8080}"
API_PID_FILE="$AI_HOME/api.pid"
MAX_AGENT_ITERATIONS=10

# --- COLORS & LOGGING ---
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'; ORANGE='\033[0;33m'; NC='\033[0m'
log() { printf "${BLUE}[%s]${NC} %s\n" "$(date '+%T')" "$*"; }
log_success() { log "${GREEN}$*${NC}"; }
log_warn() { log "${YELLOW}WARN: $*${NC}"; }
log_error() { log "${RED}ERROR: $*${NC}"; exit 1; }
log_info() { log "${CYAN}$*${NC}"; }
log_phase() { echo -e "\n${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; log "${PURPLE}$*${NC}"; echo -e "${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; }
log_worker_start() { echo -e "\n${GREEN}╔══════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"; echo -e "${GREEN}║ $1 - Model: $2 ${NC}"; echo -e "${GREEN}╚══════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"; }
log_worker_end() { echo -e "${GREEN}════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"; }

# --- BOOTSTRAP ---
mkdir -p "$AI_HOME" "$PROJECTS_DIR"

# --- SQLite UTILITIES ---
sqlite_escape() { echo "$1" | sed "s/'/''/g"; }
init_db() {
    sqlite3 "$MEMORY_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, prompt TEXT, response TEXT, task_id TEXT);" 2>/dev/null || true
    sqlite3 "$CONFIG_DB" "CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);" 2>/dev/null || true
}

# --- CONFIGURATION & MEMORY ---
set_config() { sqlite3 "$CONFIG_DB" "INSERT OR REPLACE INTO config (key, value) VALUES ('$(sqlite_escape "$1")', '$(sqlite_escape "$2")');"; log_success "Config set: $1 = $2"; }
get_config() { sqlite3 "$CONFIG_DB" "SELECT value FROM config WHERE key = '$(sqlite_escape "$1")';" 2>/dev/null; }
load_config_values() {
    MESSENGER_MODEL="$(get_config messenger_model || echo "$DEFAULT_MESSENGER_MODEL")"
    COMBINATOR_MODEL="$(get_config combinator_model || echo "$DEFAULT_COMBINATOR_MODEL")"
    TRADER_MODEL="$(get_config trader_model || echo "$DEFAULT_TRADER_MODEL")"
}
add_to_memory() { sqlite3 "$MEMORY_DB" "INSERT INTO memories (prompt, response, task_id) VALUES ('$(sqlite_escape "$1")', '$(sqlite_escape "$2")', '$3');" 2>/dev/null; }
search_memory() { sqlite3 -header -column "$MEMORY_DB" "SELECT timestamp,prompt,response FROM memories WHERE prompt LIKE '%$(sqlite_escape "$1")%' ORDER BY timestamp DESC LIMIT 5;" 2>/dev/null; }

# --- HASHING --- 
gen_task_id() { echo -n "$1$(date +%s%N)$RANDOM${AI_SEED:-}" | sha256sum | cut -c1-16; }

# --- CORE AGENT TOOLS ---
confirm_action() { echo -e "${YELLOW}CONFIRM: $1${NC}"; read -p "Type 'yes' to confirm: " -r r; [[ "$r" == "yes" ]]; }
tool_read_file() { if [[ -f "$1" ]]; then cat "$1"; else echo "ERROR: File not found: $1"; fi; }
tool_list_directory() { local p="${1:-.}"; if [[ -d "$p" ]]; then tree -L 2 "$p"; else echo "ERROR: Directory not found: $p"; fi; }
tool_web_search() { local q="$1"; if confirm_action "Search web for: $q"; then curl -sL "https://html.duckduckgo.com/html/?q=$(jq -nr --arg q "$q" '$q|@uri')" | lynx -dump -stdin -nolist; else echo "ACTION CANCELED"; fi; }
tool_write_file() { local p="$1" c="$2"; if confirm_action "Write to file: $p"; then mkdir -p "$(dirname "$p")"; echo -e "$c" > "$p"; echo "SUCCESS: File written."; else echo "ACTION CANCELED"; fi; }

# --- AI WORKER FUNCTIONS ---
ensure_ollama_server() { 
    if ! pgrep -f "ollama serve" >/dev/null; then 
        log "Ollama server starting..." 
        nohup "$OLLAMA_BIN" serve >"$AI_HOME/ollama_serve.log" 2>&1 & 
        local server_pid=$!
        sleep 5
        if ! kill -0 $server_pid 2>/dev/null; then
            log_error "Ollama server failed to start. Check $AI_HOME/ollama_serve.log"
        else
            log_success "Ollama server started (PID: $server_pid)"
        fi
    fi
}

run_worker_raw() {
    local model="$1" system_prompt="$2" conversation_history="$3"
    ensure_ollama_server
    
    local temperature="$(get_config temperature || echo "0.7")"
    local top_p="$(get_config top_p || echo "0.9")"
    local seed="$(get_config seed || echo "")"
    
    log_info "Starting worker with model: $model (temp: $temperature, top_p: $top_p)"
    
    local response_buffer="" # Buffer to capture the full AI response text
    local fifo_path=$(mktemp -u)
    mkfifo "$fifo_path"

    # Enhanced Ollama command with better error handling
    local ollama_cmd=(
        "$OLLAMA_BIN" run --verbose "$model"
        --temperature "$temperature"
        --top-p "$top_p"
        ${seed:+--seed "$seed"}
        "$system_prompt\n$conversation_history"
    )

    # Start Ollama process in background, streaming all output to FIFO
    (
        if ! "${ollama_cmd[@]}" > "$fifo_path" 2>&1; then
            echo -e "${RED}ERROR: Ollama command failed${NC}" > "$fifo_path"
        fi
    ) & 
    local ollama_pid=$!

    # Set a timeout for the read process
    local read_timeout=300  # 5 minutes timeout
    
    # Read from the FIFO line by line and process with timeout
    while IFS= read -r -t "$read_timeout" line < "$fifo_path" || [[ $? -gt 128 ]]; do
        if [[ $? -eq 128 ]]; then
            log_error "Timeout reading from Ollama process after ${read_timeout}s"
            break
        fi
        
        if [[ -z "$line" ]]; then continue; fi # Skip empty lines

        # Enhanced pattern matching for better verbose output
        if [[ "$line" =~ ^\>\>\> ]]; then
            # Ollama's internal thinking messages
            echo -e "${YELLOW}🤔 $line${NC}"
        elif [[ "$line" =~ ^\"thinking\": ]]; then
            # JSON thinking patterns
            echo -e "${YELLOW}💭 ${line:12:-1}${NC}"
        elif [[ "$line" =~ ^\{.*\}$ ]]; then
            # JSON response objects
            if echo "$line" | jq -e '.response' >/dev/null 2>&1; then
                local response_token=$(echo "$line" | jq -r '.response // empty' 2>/dev/null)
                local done_status=$(echo "$line" | jq -r '.done // false' 2>/dev/null)

                if [[ -n "$response_token" ]]; then
                    # Print response token live with subtle formatting
                    printf '%s' "$response_token"
                    response_buffer+="$response_token"
                fi
                
                if [[ "$done_status" == "true" ]]; then
                    printf '\n' # Newline after final token
                    log_success "Response generation completed"
                fi
            else
                # Other JSON output (stats, etc.)
                echo -e "${CYAN}📊 $line${NC}"
            fi
        elif [[ "$line" =~ error|ERROR|Error ]]; then
            # Error messages
            echo -e "${RED}❌ $line${NC}"
        else
            # General output
            echo -e "${BLUE}📝 $line${NC}"
        fi
    done

    # Cleanup with better error handling
    if kill -0 "$ollama_pid" 2>/dev/null; then
        log_warn "Ollama process still running, terminating..."
        kill "$ollama_pid" 2>/dev/null || true
        sleep 2
        kill -9 "$ollama_pid" 2>/dev/null || true
    fi

    rm -f "$fifo_path" 2>/dev/null || true

    echo "$response_buffer"
}

# --- ENHANCED TRIUMVIRATE MIND ARCHITECTURE ---
run_triumvirate_agent() {
    local user_prompt="$*"
    
    if [[ -z "$user_prompt" ]]; then
        log_error "No prompt provided"
        return 1
    fi

    # PHASE 0: PROJECTION & SETUP
    log_phase "PHASE 0: PROJECTION & SETUP"
    local task_id=$(gen_task_id "$user_prompt")
    local task_dir="$PROJECTS_DIR/$task_id"
    mkdir -p "$task_dir"
    log_success "Task ID (Projection): $task_id"
    log_info "Workspace: $task_dir"
    log_info "User Prompt: $user_prompt"

    # Retrieve relevant memories for context
    local relevant_memories=$(search_memory "$user_prompt")
    if [[ -n "$relevant_memories" ]]; then
        log_info "Found relevant memories for context"
    fi

    # PHASE 1: ASYNCHRONOUS BRAINSTORMING (MESSENGER & COMBINATOR)
    log_phase "PHASE 1: ASYNCHRONOUS BRAINSTORMING"
    local messenger_logfile="$task_dir/messenger.log"
    local combinator_logfile="$task_dir/combinator.log"

    local messenger_prompt_text="You are the MESSENGER, an information gatherer. Your goal is to analyze the user's request and use your tools to find all relevant information. Be thorough.\n\nTOOLS: list_directory, web_search, read_file\n\nUser Request: ${user_prompt}\n\nThink step by step and provide comprehensive information."
    
    local combinator_prompt_text="You are the COMBINATOR, a creative planner. Your goal is to brainstorm multiple potential solutions and plans based on the user's request. Think outside the box and consider various approaches.\n\nTOOLS: write_file\n\nUser Request: ${user_prompt}\n\nGenerate innovative ideas and detailed plans."

    log_info "Starting Messenger (async) with model: $MESSENGER_MODEL"
    run_worker_raw "$MESSENGER_MODEL" "$messenger_prompt_text" "$relevant_memories" > "$messenger_logfile" 2>&1 & 
    local messenger_pid=$!

    log_info "Starting Combinator (async) with model: $COMBINATOR_MODEL"
    run_worker_raw "$COMBINATOR_MODEL" "$combinator_prompt_text" "$relevant_memories" > "$combinator_logfile" 2>&1 & 
    local combinator_pid=$!

    # Enhanced waiting with progress indicator
    local spinner=('⣾' '⣽' '⣻' '⢿' '⡿' '⣟' '⣯' '⣷')
    printf "${CYAN}Brainstorming in progress... ${NC}"
    local i=0
    while kill -0 "$messenger_pid" 2>/dev/null || kill -0 "$combinator_pid" 2>/dev/null; do
        printf "\b%s" "${spinner[i++ % ${#spinner[@]}]}"
        sleep 0.1
    done
    printf "\b✅ Done.\n"

    # Read responses with error handling
    local messenger_response=""
    local combinator_response=""
    
    if [[ -f "$messenger_logfile" ]]; then
        messenger_response=$(<"$messenger_logfile")
    else
        log_error "Messenger log file not found"
        messenger_response="ERROR: Messenger response unavailable"
    fi
    
    if [[ -f "$combinator_logfile" ]]; then
        combinator_response=$(<"$combinator_logfile")
    else
        log_error "Combinator log file not found"
        combinator_response="ERROR: Combinator response unavailable"
    fi

    log_worker_start "MESSENGER BRAINSTORMING RESULTS" "$MESSENGER_MODEL"
    echo "$messenger_response"
    log_worker_end

    log_worker_start "COMBINATOR BRAINSTORMING RESULTS" "$COMBINATOR_MODEL"
    echo "$combinator_response"
    log_worker_end

    # PHASE 2: SYNTHESIS & EXECUTION (TRADER)
    log_phase "PHASE 2: SYNTHESIS & EXECUTION"
    local trader_prompt_text="You are the TRADER, the final executive decision-maker. Synthesize the information from Messenger and Combinator into an optimal, actionable plan.\n\nCRITICAL: You MUST wrap your final answer in [FINAL_ANSWER] tags.\n\n--- MESSENGER'S INFORMATION GATHERING ---\n$messenger_response\n\n--- COMBINATOR'S CREATIVE IDEAS ---\n$combinator_response\n\n--- YOUR TASK: SYNTHESIZE AND PROVIDE EXECUTABLE PLAN ---\n\nThink through each component carefully and provide a comprehensive final answer."

    log_worker_start "TRADER SYNTHESIS (LIVE THINKING)" "$TRADER_MODEL"
    local trader_response=$(run_worker_raw "$TRADER_MODEL" "$trader_prompt_text" "$relevant_memories")
    log_worker_end

    # PHASE 3: FINALIZATION & TRIGGER
    log_phase "PHASE 3: FINALIZATION & TRIGGER"
    if echo "$trader_response" | grep -q '\[FINAL_ANSWER\]'; then
        log_success "✅ Trader has produced a final actionable answer with [FINAL_ANSWER] tags."
        
        # Extract final answer more robustly
        local final_answer=$(echo "$trader_response" | sed -n '/\[FINAL_ANSWER\]/,/\[\/FINAL_ANSWER\]/p' | sed '1d;$d' | head -n -1)
        if [[ -z "$final_answer" ]]; then
            final_answer=$(echo "$trader_response" | sed -n '/\[FINAL_ANSWER\]/,$p' | sed '1d')
        fi
        
        local final_answer_payload=$(echo "$final_answer" | jq -sR . 2>/dev/null || echo "$final_answer" | sed 's/"/\\"/g')
        
        log_info "📋 Final answer prepared for external evaluation"
        printf "${GREEN}Final Answer Preview:${NC}\n"
        echo "$final_answer" | head -n 10
        if [[ $(echo "$final_answer" | wc -l) -gt 10 ]]; then
            printf "${CYAN}... (truncated, full answer saved to memory)${NC}\n"
        fi
        
        printf "\n${CYAN}To evaluate with Gemini, run:${NC}\n"
        printf "echo %s | gcloud ai models predict gemini-pro --stdin\n" "$final_answer_payload"
        
        add_to_memory "$user_prompt" "$trader_response" "$task_id"
        log_success "✅ Task completed successfully. Task ID: $task_id"
    else
        log_warn "⚠️ The Trader did not produce a [FINAL_ANSWER]. The task may be incomplete."
        log_info "Raw Trader response saved to memory for debugging."
        add_to_memory "$user_prompt" "$trader_response" "$task_id"
    fi
}

# --- DEPENDENCY CHECK ---
check_dependencies() {
    local deps=("$@")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}. Run './ai.sh --setup' to install."
    fi
}

# --- HELP & MAIN DISPATCHER ---
show_help() {
    printf "${GREEN}AI Agent v8.2 - Asynchronous Mind Edition${NC}\n"
    printf "Enhanced with comprehensive verbose thinking display\\n\\n"
    printf "${CYAN}USAGE:${NC}\\n"
    printf "  ai [OPTIONS] \\\"Your high-level goal or project idea\\\"\\n\\n"
    printf "${CYAN}OPTIONS:${NC}\\n"
    printf "  --seed <phrase>   Seed the task's unique projection with a BIP39 phrase.\\n"
    printf "  --setup           Install required dependencies.\\n"
    printf "  --help            Show this help message.\\n"
    printf "  --models          Show current model configuration.\\n"
    printf "  --memory <query>  Search memory for previous tasks.\\n\\n"
    printf "${CYAN}FEATURES:${NC}\\n"
    printf "  • Parallel brainstorming (Messenger + Combinator)\\n"
    printf "  • Live verbose thinking display\\n"
    printf "  • Executive synthesis (Trader)\\n"
    printf "  • Persistent memory and configuration\\n"
}

main() {
    # Initialize DBs and load config at start of main() for all commands
    init_db
    load_config_values

    if [[ $# -eq 0 ]]; then show_help; exit 0; fi

    local seed_phrase=""
    if [[ "$1" == "--seed" ]]; then
        if [[ $# -lt 3 ]]; then log_error "Usage: ai --seed <phrase> \"<prompt>\""; fi
        export AI_SEED="$2"
        shift 2
        log_info "Task seeded with user reflection."
    fi

    case "${1:-}" in
        "--setup")
            log_info "Checking and installing dependencies..."
            if command -v apt-get &>/dev/null; then 
                sudo apt-get update && sudo apt-get install -y sqlite3 jq curl tree lynx
            elif command -v brew &>/dev/null; then
                brew install sqlite jq curl tree lynx
            else
                log_warn "Unsupported package manager. Please install manually: sqlite3 jq curl tree lynx"
            fi
            log_success "Setup check complete."
            ;;
        "--models")
            printf "${CYAN}Current Model Configuration:${NC}\\n"
            printf "  Messenger:  %s\\n" "$MESSENGER_MODEL"
            printf "  Combinator: %s\\n" "$COMBINATOR_MODEL"
            printf "  Trader:     %s\\n" "$TRADER_MODEL"
            ;;
        "--memory")
            if [[ $# -ge 2 ]]; then
                search_memory "$2"
            else
                log_error "Usage: ai --memory <query>"
            fi
            ;;
        "--help")
            show_help
            ;;
        *)
            check_dependencies ollama sqlite3 jq curl
            run_triumvirate_agent "$@"
            ;;
    esac
}

# --- TRAP FOR CLEANUP ---
trap 'log_warn "Script interrupted."; exit 1' INT TERM

# --- ENTRY POINT ---
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
