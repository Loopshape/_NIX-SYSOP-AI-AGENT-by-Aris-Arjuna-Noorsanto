#!/usr/bin/env bash
# ai.sh - AI DevOps Platform v10.0 - The Grand Unification Edition
# A single-file, multi-modal, multi-agent AI with a complete DevOps toolkit.

set -euo pipefail
IFS=$'\n\t'

# --- CONFIGURATION ---
AI_HOME="${AI_HOME:-$HOME/.ai_agent}"
PROJECTS_DIR="${PROJECTS_DIR:-$HOME/ai_projects}"

# --- Models (can be overridden via --config) ---
DEFAULT_AGENT_MODEL="llama3.1:8b"
DEFAULT_CODEWRITER_MODEL="codellama:7b"
DEFAULT_VALIDATOR_MODEL="2244-1"

# Will be loaded from config
AGENT_MODEL=""
CODEWRITER_MODEL=""
VALIDATOR_MODEL=""

OLLAMA_BIN="$(command -v ollama || true)"
MEMORY_DB="$AI_HOME/memory.db"
CONFIG_DB="$AI_HOME/config.db"
MAX_ITERATIONS=15

# --- COLORS & LOGGING ---
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'; NC='\033[0m'
log() { printf "${BLUE}[%s]${NC} %s\n" "$(date '+%T')" "$*"; }
log_success() { log "${GREEN}$*${NC}"; }
log_warn() { log "${YELLOW}WARN: $*${NC}"; }
log_error() { log "${RED}ERROR: $*${NC}"; exit 1; }
log_info() { log "${CYAN}$*${NC}"; }
log_phase() { echo -e "\n${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; log "${PURPLE}$*${NC}"; }

# --- BOOTSTRAP & DB ---
mkdir -p "$AI_HOME" "$PROJECTS_DIR"
init_db() {
    sqlite3 "$MEMORY_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY, timestamp DATETIME, mode TEXT, prompt TEXT, result TEXT, status TEXT, task_id TEXT);" 2>/dev/null || true
    sqlite3 "$CONFIG_DB" "CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);" 2>/dev/null || true
}
sqlite_escape() { echo "$1" | sed "s/'/''/g"; }

# --- CONFIG & MEMORY ---
set_config() { sqlite3 "$CONFIG_DB" "INSERT OR REPLACE INTO config (key, value) VALUES ('$(sqlite_escape "$1")', '$(sqlite_escape "$2")');"; log_success "Config set: $1 = $2"; }
get_config() { sqlite3 "$CONFIG_DB" "SELECT value FROM config WHERE key = '$(sqlite_escape "$1")';" 2>/dev/null; }
load_config_values() {
    AGENT_MODEL=$(get_config agent_model || echo "$DEFAULT_AGENT_MODEL")
    CODEWRITER_MODEL=$(get_config codewriter_model || echo "$DEFAULT_CODEWRITER_MODEL")
    VALIDATOR_MODEL=$(get_config validator_model || echo "$DEFAULT_VALIDATOR_MODEL")
}
add_memory() { sqlite3 "$MEMORY_DB" "INSERT INTO memories (mode,prompt,result,status,task_id) VALUES ('$1','$(sqlite_escape "$2")','$(sqlite_escape "$3")','$4','$5');" 2>/dev/null; }
search_memory() { sqlite3 -header -column "$MEMORY_DB" "SELECT timestamp,mode,prompt,status FROM memories WHERE prompt LIKE '%$(sqlite_escape "$1")%' ORDER BY timestamp DESC LIMIT 5;" 2>/dev/null; }

# --- CORE UTILITIES ---
ensure_ollama_server() { if ! pgrep -f "ollama serve" >/dev/null; then log "Ollama starting..."; nohup "$OLLAMA_BIN" serve >/dev/null 2>&1 & sleep 3; fi; }
confirm_action() { echo -e "\n${YELLOW}PROPOSED ACTION:${NC} ${CYAN}$1${NC}"; read -p "Approve? [y/N] " -n 1 -r c; echo; [[ "$c" =~ ^[Yy]$ ]]; }
gen_task_id() { echo -n "$1$(date +%s%N)$RANDOM" | sha256sum | cut -c1-16; }

# --- AI INTERACTION ---
run_model_streaming() {
    local model="$1" prompt="$2"; ensure_ollama_server
    log_info "Querying model ${CYAN}$model${NC}... Output will stream below."; echo -e "${GREEN}--- AI Response ---${NC}"
    local response; response=$("$OLLAMA_BIN" run "$model" "$prompt" | tee /dev/tty); echo "$response"
}

# --- AGENT TOOLS ---
tool_read_file() { if [[ -f "$2" ]]; then cat "$2"; else echo "Error: File not found."; fi; }
tool_list_directory() { tree -L 2 "${2:-.}"; }
tool_web_search() { curl -sL "https://html.duckduckgo.com/html/?q=$(jq -nr --arg q "$2" '$q|@uri')" | lynx -dump -stdin -nolist; }
tool_write_file() { local p="$2" c="$3"; if confirm_action "Write to file: $p"; then mkdir -p "$(dirname "$p")"; echo -e "$c" > "$p"; echo "Success: File written."; else echo "User aborted."; fi; }
tool_run_command() { if confirm_action "Run command: $2"; then (eval "$2") 2>&1 || true; else echo "User aborted."; fi; }

# --- UNIFIED INTERACTIVE AGENT (DEFAULT) ---
run_unified_agent() {
    local user_prompt="$*"
    local task_id=$(gen_task_id "$user_prompt"); local project_dir="$PROJECTS_DIR/$task_id"
    mkdir -p "$project_dir"; cd "$project_dir"
    log_success "Created project workspace: $project_dir"
    
    local memories=$(search_memory "$user_prompt")
    
    local system_prompt="You are a powerful AI agent with supervised access to the local filesystem and shell. Your goal is to solve the user's request by thinking step-by-step.
TOOLS: read_file, list_directory, web_search, write_file, run_command
RULES:
1. [REASONING] First, explain your thought process and your plan.
2. [TOOL] Then, propose ONE or MORE tools to use.
3. For 'write_file', use a [CONTENT] block for multi-line content.
4. When you have enough information, provide the final answer using [FINAL_ANSWER].

--- RELEVANT MEMORIES ---
$memories
---
Begin. User Request: $user_prompt"
    
    local conversation_history="$system_prompt"; local final_answer=""
    for ((i=1; i<=MAX_ITERATIONS; i++)); do
        log_phase "Agent Iteration $i/$MAX_ITERATIONS"
        local ai_response; ai_response=$(run_model_streaming "$AGENT_MODEL" "$conversation_history")

        if [[ "$ai_response" == *"[FINAL_ANSWER]"* ]]; then
            final_answer=$(echo "$ai_response" | sed -n '/\[FINAL_ANSWER\]/,$p' | sed '1d'); break
        fi

        local tool_lines; tool_lines=$(echo "$ai_response" | grep '\[TOOL\]')
        if [[ -z "$tool_lines" ]]; then log_warn "AI did not choose a tool. Assuming final answer."; final_answer="$ai_response"; break; fi

        local all_results=""
        while IFS= read -r line; do
            local clean_line="${line#\[TOOL\] }"; local name=$(echo "$clean_line"|awk '{print $1}'); local args=$(echo "$clean_line"|cut -d' ' -f2-); local result=""
            if [[ "$name" == "write_file" ]]; then local content=$(echo "$ai_response"|awk '/\[CONTENT\]/{f=1;next}/\[\/CONTENT\]/{f=0} f'); result=$(tool_write_file "$args" "$content");
            else case "$name" in read_file|list_directory|web_search|run_command) result=$(tool_"$name" "placeholder" "$args");; *) result="Error: Unknown tool '$name'.";; esac; fi
            all_results+="\n--- Result for '$name $args' ---\n$result"
        done <<< "$tool_lines"
        echo -e "${CYAN}--- ALL TOOL RESULTS ---${NC}$all_results\n"
        conversation_history+="\n$ai_response\n[TOOL_RESULT]\n$all_results"
    done
    
    log_success "AGENT FINISHED"; echo -e "${GREEN}--- FINAL ANSWER ---${NC}\n$final_answer"
    add_memory "agent" "$user_prompt" "$final_answer" "SUCCESS" "$task_id"
}


# --- OTHER MODES & DIRECT COMMANDS ---
# Placeholders for other modes like --mode=superposition, --mode=entropic, etc.
# Each would have its own `run_*_agent` function.
code_writer() { # Direct, non-agent code generation
    local prompt="$*"; local project_dir="$PWD"; log_phase "CodeWriter Mode"
    local lang=$(run_model_streaming "$AGENT_MODEL" "Detect programming language from prompt. Output ONLY name. Prompt: $prompt")
    local system_prompt="You are an expert code generator. Write clean, working $lang code. Output ONLY the code. User Request: $prompt"
    local response=$(run_model_streaming "$CODEWRITER_MODEL" "$system_prompt")
    read -p "Save to file? (Enter filename or Enter to skip): " filename
    [[ -n "$filename" ]] && { echo "$response" > "$filename"; log_success "Saved to $filename"; }
}

run_auto_fix() { # Direct, non-agent fix
    local file_path="$1" problem="$2"; log_phase "Auto-Fix Mode for $file_path"
    local code=$(cat "$file_path"); local lang=$(detect_language "$file_path")
    local system_prompt="You are an expert debugger. Analyze the provided code and problem description. Your output must be ONLY the complete, corrected code.
Language: $lang
Problem: $problem
--- CODE WITH BUG ---
$code
--- FIXED SCRIPT ---"
    local fixed_code=$(run_model_streaming "$CODEWRITER_MODEL" "$system_prompt")
    if confirm_action "Apply the following fix to $file_path?"; then
        echo -e "${GREEN}--- PROPOSED FIX ---${NC}"; diff --color=always -u <(echo "$code") <(echo "$fixed_code") || true
        echo "$fixed_code" > "$file_path"; log_success "File fixed."
    fi
}

# ... other direct commands like run_environmental_prompt, run_recursive_assembler etc. would go here ...

# --- HELP & MAIN DISPATCHER ---
show_help() {
    printf "${GREEN}AI DevOps Platform v10.0 - The Grand Unification Edition${NC}\n\n"
    printf "A single, multi-modal, multi-agent AI with a complete DevOps toolkit.\n\n"
    printf "${CYAN}AGENT MODES:${NC}\n"
    printf "  ${GREEN}ai --mode=agent${NC} \"prompt\"   (Default) The interactive, multi-step Unified Agent.\n"
    printf "  ${GREEN}ai --mode=superposition${NC} ...  (Placeholder) The Quantum Superposition code generator.\n"
    printf "  ${GREEN}ai --mode=entropic${NC} ...      (Placeholder) The Entropic, value-verifying agent.\n"
    printf "  ${GREEN}ai --mode=mindmap${NC} ...       (Placeholder) The Cognitive Manifold agent.\n\n"
    printf "${CYAN}DIRECT COMMANDS:${NC}\n"
    printf "  ${GREEN}ai code${NC} \"prompt\"             Directly generates code.\n"
    printf "  ${GREEN}ai --fix${NC} <file> \"problem\"     Analyzes and proposes a fix for a file.\n"
    printf "  ${GREEN}ai git${NC} <op>                   Acts as a Git assistant.\n\n"
    printf "${CYAN}UTILITY:${NC}\n"
    printf "  ${GREEN}ai --setup, --config, --memory, --help${NC}\n\n"
    printf "${CYAN}EXAMPLE:${NC}\n"
    printf "  ${CYAN}ai \"Create a new nodejs project here, install express, and write a hello world server in index.js\"${NC}\n"
}

main() {
    init_db; load_config_values
    if [[ $# -eq 0 ]]; then show_help; exit 0; fi

    local agent_mode="agent" # Default mode
    local prompt_args=()
    
    # Pre-parse arguments to find mode and separate from prompt
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mode=*) agent_mode="${1#*=}"; shift ;;
            *) prompt_args+=("$1"); shift ;;
        esac
    done
    # Restore positional parameters for the main dispatcher
    set -- "${prompt_args[@]}"

    case "${1:-}" in
        --setup)
            log_info "Setting up environment..."
            if command -v apt-get &>/dev/null; then sudo apt-get update && sudo apt-get install -y sqlite3 git tree jq curl lynx; fi
            set_config agent_model "$DEFAULT_AGENT_MODEL"
            set_config codewriter_model "$DEFAULT_CODEWRITER_MODEL"
            set_config validator_model "$DEFAULT_VALIDATOR_MODEL"
            log_success "Setup complete." ;;
        --help|-h) show_help ;;
        code) shift; code_writer "$@" ;;
        --fix) if [[ $# -lt 3 ]]; then log_error "Usage: ai --fix <file> \"<problem>\""; fi; run_auto_fix "$2" "$3" ;;
        git) shift; git_operation "${1:-status}" "${2:-.}" ;;
        --config) shift; case "${1:-}" in set) set_config "$2" "$3";; get) get_config "$2";; view) view_config;; *) log_error "Usage";; esac ;;
        --memory) shift; case "${1:-}" in search) search_memory "$2";; clear) confirm_action "Clear ALL memory?" && sqlite3 "$MEMORY_DB" "DELETE FROM memories;";; *) log_error "Usage";; esac ;;
        *)
            log_phase "Activating Agent in Mode: $agent_mode"
            case "$agent_mode" in
                agent) run_unified_agent "$@" ;;
                superposition|entropic|mindmap) log_warn "Mode '$agent_mode' is a conceptual placeholder in this unified script."; run_unified_agent "$@" ;;
                *) log_error "Unknown agent mode: '$agent_mode'. Available modes: agent, superposition, entropic, mindmap." ;;
            esac
            ;;
    esac
}

# --- ENTRY POINT ---
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
