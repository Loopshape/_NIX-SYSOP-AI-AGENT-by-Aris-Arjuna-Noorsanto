#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Enhanced AI Agent with Hash-Based Indexing, Memory, and Task Pooling
# Integrated version with timestamp-based rehashing logic

# ---------------- CONFIGURATION ----------------
CONFIG_DIR="$HOME/.ai_agent"
mkdir -p "$CONFIG_DIR"
MEMORY_DB="$CONFIG_DIR/memory.db"
HASH_INDEX="$CONFIG_DIR/hash_index.json"
POOL_INDEX="$CONFIG_DIR/_pool_index.json"
PROJECTS_DIR="$HOME/ai_projects"
mkdir -p "$PROJECTS_DIR"

# Hash System Configuration
HASH_INDEX_DIR="$CONFIG_DIR/hash_registry"
HASH_DB="$HASH_INDEX_DIR/hash_registry.db"
REHASH_THRESHOLD=3600  # 1 hour in seconds

# Model configuration
DEFAULT_MODEL="llama3.1:8b"
AI_MODEL=${AI_MODEL:-$DEFAULT_MODEL}
AI_TEMPERATURE=${AI_TEMPERATURE:-0.7}
AI_TOP_P=${AI_TOP_P:-0.9}
AI_SEED=${AI_SEED:-}

# API Configuration
API_PORT=8080
API_PID_FILE="$CONFIG_DIR/api.pid"

# ---------------- COLOR CODES ----------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# ---------------- HASH INDEX SYSTEM ----------------
init_hash_system() {
    mkdir -p "$HASH_INDEX_DIR"
    sqlite3 "$HASH_DB" "CREATE TABLE IF NOT EXISTS hash_registry (
        hash TEXT PRIMARY KEY,
        original_hash TEXT,
        content_ref TEXT,
        timestamp INTEGER,
        rehash_count INTEGER DEFAULT 0,
        last_accessed INTEGER,
        content_type TEXT
    );" 2>/dev/null || true
}

# Core hash indexing with timestamp-based rehashing
hash_rehash_chain() {
    local content="$1"
    local content_type="${2:-generic}"
    local base_hash=$(echo -n "$content" | sha256sum | cut -d' ' -f1)
    local current_hash="$base_hash"
    local timestamp=$(date +%s)
    
    # Check if we need to rehash based on timestamp
    local existing_entry=$(sqlite3 "$HASH_DB" "SELECT hash, timestamp, rehash_count FROM hash_registry WHERE original_hash = '$base_hash';")
    
    if [[ -n "$existing_entry" ]]; then
        local existing_hash=$(echo "$existing_entry" | cut -d'|' -f1)
        local existing_timestamp=$(echo "$existing_entry" | cut -d'|' -f2)
        local rehash_count=$(echo "$existing_entry" | cut -d'|' -f3)
        
        # Check if rehash is needed based on timestamp threshold
        local time_diff=$((timestamp - existing_timestamp))
        if (( time_diff > REHASH_THRESHOLD )); then
            # Rehash: combine original content with timestamp
            current_hash=$(echo -n "${content}${timestamp}" | sha256sum | cut -d' ' -f1)
            rehash_count=$((rehash_count + 1))
            
            # Update registry
            sqlite3 "$HASH_DB" "UPDATE hash_registry SET 
                hash = '$current_hash',
                timestamp = $timestamp,
                rehash_count = $rehash_count,
                last_accessed = $timestamp
                WHERE original_hash = '$base_hash';"
            
            echo "🔁 Rehashed: $base_hash → $current_hash (count: $rehash_count)" >&2
        else
            # Use existing hash
            current_hash="$existing_hash"
            sqlite3 "$HASH_DB" "UPDATE hash_registry SET last_accessed = $timestamp WHERE hash = '$current_hash';"
        fi
    else
        # First time hashing this content
        sqlite3 "$HASH_DB" "INSERT INTO hash_registry (hash, original_hash, timestamp, last_accessed, rehash_count, content_type) 
                          VALUES ('$current_hash', '$base_hash', $timestamp, $timestamp, 0, '$content_type');"
    fi
    
    echo "$current_hash"
}

# Check if hash exists and return timestamp or rehash
hash_index_check() {
    local hash="$1"
    local current_timestamp=$(date +%s)
    
    local result=$(sqlite3 "$HASH_DB" "SELECT timestamp, rehash_count FROM hash_registry WHERE hash = '$hash';")
    
    if [[ -n "$result" ]]; then
        local stored_timestamp=$(echo "$result" | cut -d'|' -f1)
        local rehash_count=$(echo "$result" | cut -d'|' -f2)
        
        # Return timestamp if within threshold, otherwise indicate rehash needed
        local time_diff=$((current_timestamp - stored_timestamp))
        if (( time_diff <= REHASH_THRESHOLD )); then
            echo "timestamp:$stored_timestamp"
        else
            echo "rehash:$rehash_count"
        fi
    else
        echo "unknown"
    fi
}

# Store content with hash indexing
store_hashed_content() {
    local content="$1"
    local content_type="${2:-generic}"
    local content_hash=$(hash_rehash_chain "$content" "$content_type")
    
    # Store content in file named by hash
    local content_file="$HASH_INDEX_DIR/${content_hash}.content"
    echo "$content" > "$content_file"
    
    # Update content reference in database
    sqlite3 "$HASH_DB" "UPDATE hash_registry SET content_ref = '$content_file' WHERE hash = '$content_hash';"
    
    echo "$content_hash"
}

# Retrieve content by hash
retrieve_hashed_content() {
    local hash="$1"
    local content_file="$HASH_INDEX_DIR/${hash}.content"
    
    if [[ -f "$content_file" ]]; then
        # Update access time
        sqlite3 "$HASH_DB" "UPDATE hash_registry SET last_accessed = $(date +%s) WHERE hash = '$hash';"
        cat "$content_file"
    else
        echo "Content not found for hash: $hash"
        return 1
    fi
}

# ---------------- ENHANCED MEMORY SYSTEM ----------------
init_memory_db() {
    if ! command -v sqlite3 &> /dev/null; then
        echo -e "${RED}Error: sqlite3 is required but not installed.${NC}"
        echo "Install with: sudo apt-get install sqlite3"
        exit 1
    fi

    sqlite3 "$MEMORY_DB" "
        CREATE TABLE IF NOT EXISTS memories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            prompt TEXT NOT NULL,
            response TEXT NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            pool_hash TEXT,
            task_hash TEXT,
            semantic_hash TEXT,
            rehash_count INTEGER DEFAULT 0
        );
        CREATE TABLE IF NOT EXISTS config (
            key TEXT PRIMARY KEY,
            value TEXT
        );
        CREATE TABLE IF NOT EXISTS hashes (
            type TEXT,
            target TEXT,
            hash TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS api_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            endpoint TEXT,
            method TEXT,
            payload TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        );
    " 2>/dev/null || true
}

# SQLite escape function
sqlite_escape() {
    echo "$1" | sed "s/'/''/g"
}

# Enhanced memory functions with hash indexing
add_to_memory() {
    local prompt="$1"
    local response="$2"
    local pool_hash="$3"
    local task_hash="$4"
    
    # Generate semantic hash for the prompt
    local semantic_hash=$(generate_semantic_hash "$prompt")
    
    # Store in memory database
    sqlite3 "$MEMORY_DB" "
        INSERT INTO memories (prompt, response, pool_hash, task_hash, semantic_hash)
        VALUES ('$(sqlite_escape "$prompt")', '$(sqlite_escape "$response")', '$pool_hash', '$task_hash', '$semantic_hash');
    " 2>/dev/null
    
    # Also store in hash index system for fast lookup
    store_hashed_content "$response" "memory_response" > /dev/null
}

# Enhanced memory search with hash indexing
search_memory() {
    local query="$1"
    local limit="${2:-5}"
    
    # First try exact hash-based lookup
    local query_hash=$(generate_semantic_hash "$query")
    local cached_result=$(sqlite3 "$MEMORY_DB" "
        SELECT prompt, response, timestamp, pool_hash 
        FROM memories 
        WHERE semantic_hash = '$query_hash' 
        ORDER BY timestamp DESC 
        LIMIT 1;
    " 2>/dev/null)
    
    if [[ -n "$cached_result" ]]; then
        echo "$cached_result"
        return 0
    fi
    
    # Fall back to semantic search
    sqlite3 "$MEMORY_DB" "
        SELECT prompt, response, timestamp, pool_hash
        FROM memories
        WHERE prompt LIKE '%$(sqlite_escape "$query")%' OR response LIKE '%$(sqlite_escape "$query")%'
        ORDER BY timestamp DESC
        LIMIT $limit;
    " 2>/dev/null
}

clear_memory() {
    local confirm
    echo -e "${YELLOW}⚠️  This will clear ALL memory data.${NC}"
    read -p "Are you sure you want to clear all memory? (y/N): " confirm
    if [[ $confirm == "y" || $confirm == "Y" ]]; then
        sqlite3 "$MEMORY_DB" "DELETE FROM memories; DELETE FROM hashes;" 2>/dev/null
        rm -rf "$HASH_INDEX_DIR"
        init_hash_system
        echo -e "${GREEN}✅ Memory cleared successfully.${NC}"
    else
        echo -e "${BLUE}ℹ️  Memory clearance cancelled.${NC}"
    fi
}

# ---------------- HASH GENERATION ----------------
generate_semantic_hash() {
    local text="$1"
    echo -n "$text" | sha256sum | cut -d' ' -f1 | cut -c1-16
}

generate_instance_hash() {
    local text="$1"
    echo -n "$text-$(date +%s%N)" | sha256sum | cut -d' ' -f1 | cut -c1-16
}

# ---------------- TASK POOLING WITH HASH INDEXING ----------------
setup_task_pool() {
    local prompt="$1"
    local semantic_hash=$(generate_semantic_hash "$prompt")
    local instance_hash=$(generate_instance_hash "$prompt")
    local pool_dir="$PROJECTS_DIR/$semantic_hash"
    local task_dir="$pool_dir/$instance_hash"
    
    mkdir -p "$task_dir"
    
    # Check hash index for existing tasks
    local hash_result=$(hash_index_check "$semantic_hash")
    local rehash_count=0
    
    case "$hash_result" in
        timestamp:*)
            local timestamp="${hash_result#timestamp:}"
            rehash_count=$(sqlite3 "$HASH_DB" "SELECT rehash_count FROM hash_registry WHERE hash = '$semantic_hash';" 2>/dev/null || echo "0")
            ;;
        rehash:*)
            rehash_count="${hash_result#rehash:}"
            # Update the hash with new timestamp
            store_hashed_content "$prompt" "task_prompt" > /dev/null
            ;;
        *)
            # New task, store in hash system
            store_hashed_content "$prompt" "task_prompt" > /dev/null
            ;;
    esac
    
    # Update rehash count
    rehash_count=$((rehash_count + 1))
    
    echo "$semantic_hash $instance_hash $rehash_count"
}

# ---------------- ENHANCED AI WORKFLOW ----------------
MESSENGER_SYSTEM_PROMPT="You are Messenger, the research specialist. Your role is to gather information through web research and analyze data. When encountering research queries, prioritize using web_search for broad research and read_web_page for specific URLs. Consider recent memories and research findings when planning responses. Always seek user confirmation before external actions. Provide detailed, well-researched information."

COMBINATOR_SYSTEM_PROMPT="You are Combinator, the planning specialist. Your role is to analyze research findings from Messenger and create comprehensive plans. Consider the task pool resonance (rehash_count) when planning - higher counts indicate frequently requested tasks that may need optimized solutions. Create step-by-step plans that Trader can execute."

TRADER_SYSTEM_PROMPT="You are Trader, the execution specialist. Your role is to implement plans created by Combinator. You have access to code execution, file operations, and external tools. Always supervise file operations and network requests with user confirmation. Consider memory context and task resonance in your implementations. Provide clear, executable solutions."

run_worker() {
    local role="$1"
    local prompt="$2"
    local memories="$3"
    local rehash_count="${4:-0}"
    
    local system_prompt=""
    case $role in
        "messenger") system_prompt="$MESSENGER_SYSTEM_PROMPT" ;;
        "combinator") system_prompt="$COMBINATOR_SYSTEM_PROMPT" ;;
        "trader") system_prompt="$TRADER_SYSTEM_PROMPT" ;;
    esac
    
    # Inject memories and resonance into prompt
    local enhanced_prompt="## CONTEXT AND MEMORIES ##
Previous relevant memories:
$memories

## TASK RESONANCE ##
This type of task has been requested $rehash_count times before.

## CURRENT TASK ##
$prompt

## INSTRUCTIONS ##
Think step by step and provide a comprehensive response."
    
    echo -e "${PURPLE}🤖 $role is thinking...${NC}"
    echo -e "${CYAN}=======================${NC}"
    
    # Create temporary file for the prompt
    local temp_prompt=$(mktemp)
    echo "$system_prompt" > "$temp_prompt"
    echo -e "\n$enhanced_prompt" >> "$temp_prompt"
    
    # Stream output while capturing for memory
    local response=""
    local line
    {
        while IFS= read -r line; do
            echo -e "${BLUE}$line${NC}"
            response+="$line"$'\n'
        done
    } < <(ollama run --model "$AI_MODEL" --temperature "$AI_TEMPERATURE" --top-p "$AI_TOP_P" ${AI_SEED:+--seed $AI_SEED} < "$temp_prompt" 2>/dev/null || echo "Error: Failed to get AI response. Check if Ollama is running and model is available.")
    
    rm -f "$temp_prompt"
    
    echo -e "${CYAN}=======================${NC}"
    echo "$response"
}

# ---------------- TOOLS WITH HASH VERIFICATION ----------------
tool_web_search() {
    local query="$1"
    echo -e "${CYAN}🔍 Web search requested for:${NC} $query"
    read -p "Confirm web search? (y/N): " confirm
    if [[ $confirm != "y" && $confirm != "Y" ]]; then
        echo -e "${YELLOW}❌ Web search cancelled by user.${NC}"
        return 1
    fi
    
    # Hash the query for tracking
    store_hashed_content "$query" "web_search" > /dev/null
    
    echo -e "${GREEN}✅ Performing web search for: $query${NC}"
    # Simulate search results
    echo -e "${BLUE}Search results would include relevant information about: $query${NC}"
    echo "1. Overview of $query"
    echo "2. Key concepts and applications"
    echo "3. Recent developments"
    echo "4. Related resources"
}

tool_read_web_page() {
    local url="$1"
    echo -e "${CYAN}🌐 Web page read requested:${NC} $url"
    read -p "Confirm reading web page? (y/N): " confirm
    if [[ $confirm != "y" && $confirm != "Y" ]]; then
        echo -e "${YELLOW}❌ Web page reading cancelled by user.${NC}"
        return 1
    fi
    
    # Hash the URL for tracking
    store_hashed_content "$url" "web_page" > /dev/null
    
    echo -e "${GREEN}✅ Reading web page: $url${NC}"
    # Simulate page content extraction
    echo -e "${BLUE}Page content would be extracted and analyzed here...${NC}"
    echo "Title: Example Page about AI"
    echo "Content: This page contains valuable information about artificial intelligence applications..."
    echo "Key points: Machine learning, neural networks, AI ethics"
}

tool_write_file() {
    local file_path="$1"
    local content="$2"
    
    echo -e "${CYAN}📝 Write file requested:${NC} $file_path"
    echo -e "${YELLOW}Content preview (first 10 lines):${NC}"
    echo "---"
    echo "$content" | head -10
    echo "---"
    
    read -p "Confirm file write? (y/N): " confirm
    if [[ $confirm != "y" && $confirm != "Y" ]]; then
        echo -e "${YELLOW}❌ File write cancelled by user.${NC}"
        return 1
    fi
    
    # Hash the content for tracking and deduplication
    local content_hash=$(store_hashed_content "$content" "file_content")
    echo -e "${BLUE}Content hash: $content_hash${NC}"
    
    mkdir -p "$(dirname "$file_path")"
    echo "$content" > "$file_path"
    echo -e "${GREEN}✅ File written successfully: $file_path${NC}"
}

tool_run_command() {
    local command="$1"
    
    echo -e "${CYAN}⚡ Command execution requested:${NC} $command"
    read -p "Confirm command execution? (y/N): " confirm
    if [[ $confirm != "y" && $confirm != "Y" ]]; then
        echo -e "${YELLOW}❌ Command execution cancelled by user.${NC}"
        return 1
    fi
    
    # Hash the command for tracking
    store_hashed_content "$command" "command" > /dev/null
    
    echo -e "${GREEN}✅ Executing command...${NC}"
    eval "$command"
    local exit_code=$?
    echo -e "${BLUE}Command exited with code: $exit_code${NC}"
    return $exit_code
}

# ---------------- ENHANCED TRIUMVIRATE AGENT ----------------
run_triumvirate_agent() {
    local user_prompt="$*"
    
    if [[ -z "$user_prompt" ]]; then
        echo -e "${RED}Error: No prompt provided.${NC}"
        return 1
    fi
    
    echo -e "${GREEN}🧠 AI Agent Processing:${NC} $user_prompt"
    
    # Initialize systems
    init_memory_db
    init_hash_system
    
    # Check hash cache first
    local prompt_hash=$(generate_semantic_hash "$user_prompt")
    local cache_result=$(hash_index_check "$prompt_hash")
    
    case "$cache_result" in
        timestamp:*)
            echo -e "${GREEN}✅ Using cached response (recent).${NC}"
            local cached_content=$(retrieve_hashed_content "$prompt_hash" 2>/dev/null)
            if [[ -n "$cached_content" ]]; then
                echo -e "${BLUE}$cached_content${NC}"
                return 0
            fi
            ;;
        rehash:*)
            local rehash_count="${cache_result#rehash:}"
            echo -e "${YELLOW}🔄 Cache entry needs refresh (rehashed $rehash_count times). Recomputing...${NC}"
            ;;
        *)
            echo -e "${BLUE}🔍 No cache found, computing fresh response...${NC}"
            ;;
    esac
    
    # Set up task pooling
    local pool_info=$(setup_task_pool "$user_prompt")
    local semantic_hash=$(echo "$pool_info" | cut -d' ' -f1)
    local instance_hash=$(echo "$pool_info" | cut -d' ' -f2)
    local rehash_count=$(echo "$pool_info" | cut -d' ' -f3)
    
    echo -e "${BLUE}📊 Task pool: $semantic_hash (resonance: $rehash_count)${NC}"
    
    # Search for relevant memories
    local relevant_memories=$(search_memory "$user_prompt")
    local memory_count=$(echo "$relevant_memories" | grep -c "|" || true)
    echo -e "${BLUE}💾 Retrieved memories: $memory_count relevant entries${NC}"
    
    # Messenger phase - research and information gathering
    echo -e "${YELLOW}🚀 Starting Messenger phase...${NC}"
    local messenger_response=$(run_worker "messenger" "Research and gather information for: $user_prompt" "$relevant_memories" "$rehash_count")
    
    # Combinator phase - planning with research findings
    echo -e "${YELLOW}🚀 Starting Combinator phase...${NC}"
    local combinator_response=$(run_worker "combinator" "Create a detailed execution plan using this research: $messenger_response" "$relevant_memories" "$rehash_count")
    
    # Trader phase - execution with supervision
    echo -e "${YELLOW}🚀 Starting Trader phase...${NC}"
    local trader_response=$(run_worker "trader" "Execute this plan with proper supervision: $combinator_response" "$relevant_memories" "$rehash_count")
    
    # Store in memory and hash index
    add_to_memory "$user_prompt" "$trader_response" "$semantic_hash" "$instance_hash"
    
    # Cache the final response in hash system
    store_hashed_content "$trader_response" "agent_response" > /dev/null
    
    echo -e "${GREEN}✅ Task completed and stored in memory.${NC}"
    echo -e "${BLUE}📁 Task location: $PROJECTS_DIR/$semantic_hash/$instance_hash${NC}"
    
    # Save full response to task directory
    local task_dir="$PROJECTS_DIR/$semantic_hash/$instance_hash"
    echo "User Prompt: $user_prompt" > "$task_dir/full_response.txt"
    echo "Messenger: $messenger_response" >> "$task_dir/full_response.txt"
    echo "Combinator: $combinator_response" >> "$task_dir/full_response.txt"
    echo "Trader: $trader_response" >> "$task_dir/full_response.txt"
    echo "Hash: $prompt_hash" >> "$task_dir/full_response.txt"
    echo "Rehash Count: $rehash_count" >> "$task_dir/full_response.txt"
}

# ---------------- HASH MANAGEMENT COMMANDS ----------------
hash_file() {
    local file_path="$1"
    if [[ ! -f "$file_path" ]]; then
        echo -e "${RED}Error: File not found: $file_path${NC}"
        return 1
    fi
    local content=$(cat "$file_path")
    local hash=$(store_hashed_content "$content" "file")
    echo -e "${GREEN}File hash: ${hash}${NC}"
}

hash_prompt() {
    local prompt="$1"
    local hash=$(store_hashed_content "$prompt" "prompt")
    echo -e "${GREEN}Prompt hash: ${hash}${NC}"
}

hash_repo() {
    local repo_path="${1:-.}"
    if [[ ! -d "$repo_path" ]]; then
        echo -e "${RED}Error: Directory not found: $repo_path${NC}"
        return 1
    fi
    local content=$(find "$repo_path" -type f \( -name "*.go" -o -name "*.py" -o -name "*.js" -o -name "*.json" -o -name "*.sh" \) -exec cat {} \; 2>/dev/null | head -c 10000)
    local hash=$(store_hashed_content "$content" "repository")
    echo -e "${GREEN}Repository hash: ${hash}${NC}"
}

hash_status() {
    echo -e "${CYAN}📊 Hash System Status:${NC}"
    sqlite3 "$HASH_DB" "SELECT 
        COUNT(*) as total_entries, 
        SUM(rehash_count) as total_rehashes,
        AVG(rehash_count) as avg_rehashes,
        MAX(timestamp) as latest_entry 
        FROM hash_registry;" | awk -F'|' '
    {
        "date -d @" $4 " +%Y-%m-%d %H:%M:%S" | getline timestamp
        print "  Total Entries: " $1
        print "  Total Rehashes: " $2
        print "  Average Rehashes: " $3
        print "  Latest Entry: " timestamp
    }'
}

# ---------------- CONFIGURATION MANAGEMENT ----------------
config_set() {
    local key="$1"
    local value="$2"
    sqlite3 "$MEMORY_DB" "INSERT OR REPLACE INTO config (key, value) VALUES ('$key', '$value');" 2>/dev/null
    echo -e "${GREEN}✅ Config set: $key = $value${NC}"
}

config_get() {
    local key="$1"
    local value=$(sqlite3 "$MEMORY_DB" "SELECT value FROM config WHERE key = '$key';" 2>/dev/null)
    if [[ -n "$value" ]]; then
        echo -e "${BLUE}$key: $value${NC}"
    else
        echo -e "${YELLOW}Config key not found: $key${NC}"
    fi
}

config_view() {
    echo -e "${CYAN}📋 Current Configuration:${NC}"
    sqlite3 "$MEMORY_DB" "SELECT key, value FROM config;" 2>/dev/null | while IFS='|' read key value; do
        echo -e "${BLUE}  $key: $value${NC}"
    done
}

# ---------------- MAIN CLI INTERFACE ----------------
main() {
    case "${1:-}" in
        "--config")
            case "${2:-}" in
                "view") config_view ;;
                "get") config_get "${3:-}" ;;
                "set") config_set "${3:-}" "${4:-}" ;;
                *) echo -e "${RED}Usage: agi --config [view|get|set]${NC}" ;;
            esac
            ;;
        "--hash")
            case "${2:-}" in
                "file") hash_file "${3:-}" ;;
                "prompt") hash_prompt "${3:-}" ;;
                "repo") hash_repo "${3:-}" ;;
                "status") hash_status ;;
                *) echo -e "${RED}Usage: agi --hash [file|prompt|repo|status]${NC}" ;;
            esac
            ;;
        "--memory")
            case "${2:-}" in
                "search") search_memory "${3:-}" ;;
                "clear") clear_memory ;;
                *) echo -e "${RED}Usage: agi --memory [search|clear]${NC}" ;;
            esac
            ;;
        "--tools")
            echo -e "${CYAN}Available tools:${NC}"
            echo -e "  tool_web_search <query>"
            echo -e "  tool_read_web_page <url>"
            echo -e "  tool_write_file <path> <content>"
            echo -e "  tool_run_command <command>"
            ;;
        "--help"|"-h"|"")
            cat << EOF
${GREEN}Enhanced AI Agent with Hash-Based Indexing${NC}

${CYAN}Basic Usage:${NC}
  agi "your prompt here"          - Run AI agent with prompt
  agi --help                      - Show this help

${CYAN}Configuration:${NC}
  agi --config view               - View all configuration
  agi --config get <key>          - Get configuration value
  agi --config set <key> <value>  - Set configuration

${CYAN}Hashing:${NC}
  agi --hash file <path>          - Hash a file
  agi --hash prompt "text"        - Hash a prompt
  agi --hash repo [path]          - Hash a repository
  agi --hash status               - Show hash system status

${CYAN}Memory:${NC}
  agi --memory search "query"     - Search memory
  agi --memory clear              - Clear memory (with confirmation)

${CYAN}Tools:${NC}
  agi --tools                     - List available tools

${CYAN}Environment Variables:${NC}
  AI_MODEL="llama3.1:8b"         - Set AI model
  AI_TEMPERATURE=0.7             - Set temperature (0-1)
  AI_TOP_P=0.9                   - Set top_p (0-1)
  AI_SEED=                       - Set random seed

${YELLOW}Hash Rehashing Logic:${NC}
  The system automatically rehashes content every $REHASH_THRESHOLD seconds
  to ensure cache freshness while maintaining efficient lookups.

${YELLOW}Examples:${NC}
  agi "Explain quantum computing"
  agi --config set temperature 0.5
  agi --hash file ./script.sh
  agi --memory search "python"
EOF
            ;;
        *)
            # If no recognized flag, treat as prompt
            run_triumvirate_agent "$@"
            ;;
    esac
}

# ---------------- INITIALIZATION ----------------
check_ollama() {
    if ! command -v ollama &> /dev/null; then
        echo -e "${RED}Error: Ollama is not installed or not in PATH.${NC}"
        echo "Install from: https://ollama.ai"
        exit 1
    fi
}

first_time_setup() {
    if [[ ! -f "$CONFIG_DIR/setup_complete" ]]; then
        echo -e "${GREEN}🎉 First-time setup initializing...${NC}"
        init_memory_db
        init_hash_system
        config_set "default_model" "$DEFAULT_MODEL"
        config_set "temperature" "$AI_TEMPERATURE"
        config_set "top_p" "$AI_TOP_P"
        config_set "rehash_threshold" "$REHASH_THRESHOLD"
        touch "$CONFIG_DIR/setup_complete"
        echo -e "${GREEN}✅ Setup completed!${NC}"
    fi
}

# ---------------- EXECUTION ----------------
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    first_time_setup
    check_ollama
    main "$@"
fi
